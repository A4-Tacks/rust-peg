use codegen::RustWriter;
use std::io;
use std::str;
mod codegen;

struct Grammar {
	rules: ~[~Rule]
}

enum Item {
	Rule
}

struct Rule {
	name: ~str,
	expr: ~Expr,
}

enum Attr {
	AttrDefineParser(~str),
	AttrDefineType(~str)
}

struct CharSetCase {
	start: char,
	end: char
}

enum Expr {
	AnyCharExpr,
	LiteralExpr(~str),
	CharSetExpr(bool, ~[CharSetCase]),
	RuleExpr(~str),
	SequenceExpr(~[~Expr]),
	ChoiceExpr(~[~Expr]),
	OptionalExpr(~Expr),
	ZeroOrMore(~Expr),
	OneOrMore(~Expr),
	DelimitedExpr(~Expr, ~Expr),
	PosAssertExpr(~Expr),
	NegAssertExpr(~Expr),
	StringifyExpr(~Expr),
}

fn compile_grammar(w: &RustWriter, grammar: &Grammar) {
	compile_header(w);

	for rule in grammar.rules.iter() {
		compile_rule(w, *rule);
	}
}



fn compile_header(w: &RustWriter) {
	w.write("// Generated by rust-peg. Do not edit.
use std::str::{CharRange};

#[inline]
fn slice_eq(input: &str, pos: uint, m: &str) -> Result<uint, uint> {
    let l = m.len();
    if (input.len() >= pos + l && input.slice(pos, pos+l) == m) {
        Ok(pos+l)
    } else {
        Err(pos)
    }
}

#[inline]
fn any_char(input: &str, pos: uint) -> Result<uint, uint> {
    if input.len() > pos {
        Ok(input.char_range_at(pos).next)
    } else {
        Err(pos)
    }
}
");
}


fn compile_rule(w: &RustWriter, rule: &Rule) {
	do w.def_fn(false, "parse_"+rule.name, "input: &str, pos: uint", "Result<uint, uint>") {
		compile_expr(w, rule.expr);
	}
}

fn compile_match_and_then(w: &RustWriter, e: &Expr, then: &fn()) {
	do w.let_block("seq_res") {
		compile_expr(w, e);
	}
	do w.match_block("seq_res") {
		w.match_inline_case("Err(pos)", "Err(pos)");
		do w.match_case("Ok(pos)") {
			then();
		}
	}
}

fn compile_zero_or_more(w: &RustWriter, e: &Expr) {
	w.let_mut_stmt("repeat_pos", "pos");
	do w.loop_block {
		do w.let_block("step_res") {
			w.let_stmt("pos", "repeat_pos");
			compile_expr(w, e);
		}
		do w.match_block("step_res") {
			do w.match_case("Ok(newpos)") {
				w.line("repeat_pos = newpos;");
			}
			do w.match_case("Err(*)") {
				w.line("break;");
			}
		}
	}
	w.line("Ok(repeat_pos)");
}

fn compile_expr(w: &RustWriter, e: &Expr) {
	match *e {
		AnyCharExpr => { 
			w.line("any_char(input, pos)");
			/*w.if_else("input.len() > pos",
				||{ w.line("Ok(pos+1)"); },
				||{ w.line("Err(pos)"); }
			);*/
		}

		LiteralExpr(ref s) => {
			w.line("slice_eq(input, pos, \""+*s+"\")");
			/*w.if_else("slice_eq(input, pos, \""+*s+"\")",
				||{ w.line("Ok(pos+" + s.len().to_str() + ")"); },
				||{ w.line("Err(pos)"); }
			);*/
		}

		CharSetExpr(invert, ref cases) => {
			w.if_else("input.len() > pos",
				|| {
					w.line("let CharRange {ch, next} = input.char_range_at(pos);");
					do w.match_block("ch") {
						w.write_indent();
						for (i, case) in cases.iter().enumerate() {
							if i != 0 { w.write(" | "); }
							if case.start == case.end {
								w.write("'"+str::from_char(case.start)+"'");
							} else {
								w.write("'"+str::from_char(case.start)+"'..'"+str::from_char(case.end)+"'");
							}
						}
						w.write(" => { Ok(next) }\n");
						w.match_inline_case("_", "Err(pos)");
					}
				},
				|| { w.line("Err(pos)"); }
			)
		}
		
		RuleExpr(ref ruleName) => {
			w.line("parse_"+*ruleName+"(input, pos)");
		}

		SequenceExpr(ref exprs) => {
			fn write_seq(w: &RustWriter, exprs: &[~Expr]) {
				if (exprs.len() == 1) {
					compile_expr(w, exprs[0]);
				} else {
					do compile_match_and_then(w, exprs[0]) {
						write_seq(w, exprs.tail());
					}
				}
			}

			if (exprs.len() > 0 ) {
				write_seq(w, *exprs);
			}
		}

		ChoiceExpr(ref exprs) => {
			fn write_choice(w: &RustWriter, exprs: &[~Expr]) {
				if (exprs.len() == 1) {
					compile_expr(w, exprs[0]);
				} else {
					do w.let_block("choice_res") {
						compile_expr(w, exprs[0]);
					}
					do w.match_block("choice_res") {
						w.match_inline_case("Ok(pos)", "Ok(pos)");
						do w.match_case("Err(*)") {
							write_choice(w, exprs.tail());
						}
					}
				}
			}

			if (exprs.len() > 0 ) {
				write_choice(w, *exprs);
			}
		}

		OptionalExpr(ref e) => {
			do w.let_block("optional_res") {
				compile_expr(w, *e);
			}
			do w.match_block("optional_res") {
				w.match_inline_case("Ok(newpos)", "Ok(newpos)");
				w.match_inline_case("Err(*)", "Ok(pos)");
			}
		}
		
		ZeroOrMore(ref e) => {
			compile_zero_or_more(w, *e);
		}

		OneOrMore(ref e) => {
			do compile_match_and_then(w, *e) {
				compile_zero_or_more(w, *e);
			}
		}
		
		DelimitedExpr(ref e, _) => fail!("not implemented"),

		  StringifyExpr(*)
		| PosAssertExpr(*)
		| NegAssertExpr(*) => fail!("not implemented"),

	}
}

fn main() {
	let grammar = ~Grammar { rules: ~[
		~Rule {
			name: ~"sum",
			expr: ~SequenceExpr(~[
				~RuleExpr(~"product"),
				~OptionalExpr(
					~SequenceExpr(~[
						~LiteralExpr(~"+"),
						~RuleExpr(~"product")
						]))

				])
		},
		~Rule {
			name: ~"product",
			expr: ~SequenceExpr(~[
				~RuleExpr(~"atom"),
				~OptionalExpr(
					~SequenceExpr(~[
						~LiteralExpr(~"*"),
						~RuleExpr(~"atom")
						]))

				])
		},
		~Rule {
			name: ~"parens",
			expr: ~SequenceExpr(~[
				~LiteralExpr(~"("),
					~RuleExpr(~"sum"),
					~LiteralExpr(~")")
					])
		},
		~Rule {
			name: ~"number",
			expr: ~OneOrMore(
				~CharSetExpr(false, ~[CharSetCase{start:'0', end: '9'}]))

		},
		~Rule {
			name: ~"atom",
			expr: ~ChoiceExpr(~[
				~RuleExpr(~"number"),
				~RuleExpr(~"parens")
				])
		}
		]
	}
	;


	let w = RustWriter::new(io::stdout());
	compile_grammar(&w, grammar);
}