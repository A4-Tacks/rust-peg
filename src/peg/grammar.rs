// Generated by rust-peg. Do not edit.
extern mod std;
use std::str::{CharRange};
    
	use peg::*;
  use std::num::from_str_radix;

#[inline]
fn slice_eq(input: &str, pos: uint, m: &str) -> Result<(uint, ()), uint> {
    let l = m.len();
    if (input.len() >= pos + l && input.slice(pos, pos+l) == m) {
        Ok((pos+l, ()))
    } else {
        Err(pos)
    }
}

#[inline]
fn any_char(input: &str, pos: uint) -> Result<(uint, ()), uint> {
    if input.len() > pos {
        Ok((input.char_range_at(pos).next, ()))
    } else {
        Err(pos)
    }
}
#[allow(unused_variable)]
fn parse_grammar(input: &str, pos: uint) -> Result<(uint, ~Grammar) , uint> {
    let start_pos = pos;
    let seq_res = {
        parse___(input, pos)
    };
    match seq_res {
        Err(pos) => Err(pos),
        Ok((pos, _)) => {
            let seq_res = {
                let optional_res = {
                    parse_action(input, pos)
                };
                match optional_res {
                    Ok((newpos, value)) => Ok((newpos, Some(value))),
                    Err(*) => Ok((pos, None)),
                }
            };
            match seq_res {
                Err(pos) => Err(pos),
                Ok((pos, header)) => {
                    let seq_res = {
                        let mut repeat_pos = pos;
                        let mut repeat_value = ~[];
                        loop {
                            let step_res = {
                                let pos = repeat_pos;
                                parse_rule(input, pos)
                            };
                            match step_res {
                                Ok((newpos, value)) => {
                                    repeat_pos = newpos;
                                    repeat_value.push(value);
                                }
                                Err(*) => {
                                    break;
                                }
                            }
                        }
                        Ok((repeat_pos, repeat_value))
                    };
                    match seq_res {
                        Err(pos) => Err(pos),
                        Ok((pos, rules)) => {
                            let match_str = input.slice(start_pos, pos);;
                            Ok((pos, {
  	  ~Grammar{ initializer:header, rules:rules }
    }))
                        }
                    }
                }
            }
        }
    }
}
pub fn grammar(input: &str) -> Result<~Grammar, ~str> {
    match parse_grammar(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_rule(input: &str, pos: uint) -> Result<(uint, ~Rule) , uint> {
    let start_pos = pos;
    let seq_res = {
        parse_identifier(input, pos)
    };
    match seq_res {
        Err(pos) => Err(pos),
        Ok((pos, name)) => {
            let seq_res = {
                parse_returntype(input, pos)
            };
            match seq_res {
                Err(pos) => Err(pos),
                Ok((pos, returns)) => {
                    let seq_res = {
                        parse_equals(input, pos)
                    };
                    match seq_res {
                        Err(pos) => Err(pos),
                        Ok((pos, _)) => {
                            let seq_res = {
                                parse_expression(input, pos)
                            };
                            match seq_res {
                                Err(pos) => Err(pos),
                                Ok((pos, expression)) => {
                                    let seq_res = {
                                        let optional_res = {
                                            parse_semicolon(input, pos)
                                        };
                                        match optional_res {
                                            Ok((newpos, value)) => Ok((newpos, Some(value))),
                                            Err(*) => Ok((pos, None)),
                                        }
                                    };
                                    match seq_res {
                                        Err(pos) => Err(pos),
                                        Ok((pos, _)) => {
                                            let match_str = input.slice(start_pos, pos);;
                                            Ok((pos, {
  	  ~Rule{ name: name, expr: expression, ret_type: returns }
    }))
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
pub fn rule(input: &str) -> Result<~Rule, ~str> {
    match parse_rule(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_returntype(input: &str, pos: uint) -> Result<(uint, ~str) , uint> {
    let choice_res = {
        let start_pos = pos;
        let seq_res = {
            parse_returns(input, pos)
        };
        match seq_res {
            Err(pos) => Err(pos),
            Ok((pos, _)) => {
                let seq_res = {
                    let start_pos = pos;
                    let seq_res = {
                        parse_rust_type(input, pos)
                    };
                    match seq_res {
                        Err(pos) => Err(pos),
                        Ok((pos, _)) => {
                            let match_str = input.slice(start_pos, pos);;
                            Ok((pos, {match_str.trim().to_owned()}))
                        }
                    }
                };
                match seq_res {
                    Err(pos) => Err(pos),
                    Ok((pos, tp)) => {
                        let match_str = input.slice(start_pos, pos);;
                        Ok((pos, { tp }))
                    }
                }
            }
        }
    };
    match choice_res {
        Ok((pos, value)) => Ok((pos, value)),
        Err(*) => {
            let start_pos = pos;
            let match_str = input.slice(start_pos, pos);;
            Ok((pos, { ~"()" }))
        }
    }
}
pub fn returntype(input: &str) -> Result<~str, ~str> {
    match parse_returntype(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_rust_type(input: &str, pos: uint) -> Result<(uint, ()) , uint> {
    let choice_res = {
        let seq_res = {
            slice_eq(input, pos, "()")
        };
        match seq_res {
            Err(pos) => Err(pos),
            Ok((pos, _)) => {
                parse___(input, pos)
            }
        }
    };
    match choice_res {
        Ok((pos, value)) => Ok((pos, value)),
        Err(*) => {
            let choice_res = {
                let seq_res = {
                    slice_eq(input, pos, "~")
                };
                match seq_res {
                    Err(pos) => Err(pos),
                    Ok((pos, _)) => {
                        let seq_res = {
                            parse___(input, pos)
                        };
                        match seq_res {
                            Err(pos) => Err(pos),
                            Ok((pos, _)) => {
                                parse_rust_type(input, pos)
                            }
                        }
                    }
                }
            };
            match choice_res {
                Ok((pos, value)) => Ok((pos, value)),
                Err(*) => {
                    let choice_res = {
                        let seq_res = {
                            slice_eq(input, pos, "[")
                        };
                        match seq_res {
                            Err(pos) => Err(pos),
                            Ok((pos, _)) => {
                                let seq_res = {
                                    parse_rust_type(input, pos)
                                };
                                match seq_res {
                                    Err(pos) => Err(pos),
                                    Ok((pos, _)) => {
                                        let seq_res = {
                                            slice_eq(input, pos, "]")
                                        };
                                        match seq_res {
                                            Err(pos) => Err(pos),
                                            Ok((pos, _)) => {
                                                parse___(input, pos)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    };
                    match choice_res {
                        Ok((pos, value)) => Ok((pos, value)),
                        Err(*) => {
                            let choice_res = {
                                let seq_res = {
                                    parse_identifier(input, pos)
                                };
                                match seq_res {
                                    Err(pos) => Err(pos),
                                    Ok((pos, _)) => {
                                        let seq_res = {
                                            slice_eq(input, pos, "<")
                                        };
                                        match seq_res {
                                            Err(pos) => Err(pos),
                                            Ok((pos, _)) => {
                                                let seq_res = {
                                                    parse_rust_type(input, pos)
                                                };
                                                match seq_res {
                                                    Err(pos) => Err(pos),
                                                    Ok((pos, _)) => {
                                                        let seq_res = {
                                                            slice_eq(input, pos, ">")
                                                        };
                                                        match seq_res {
                                                            Err(pos) => Err(pos),
                                                            Ok((pos, _)) => {
                                                                parse___(input, pos)
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            };
                            match choice_res {
                                Ok((pos, value)) => Ok((pos, value)),
                                Err(*) => {
                                    let seq_res = {
                                        parse_identifier(input, pos)
                                    };
                                    match seq_res {
                                        Err(pos) => Err(pos),
                                        Ok((pos, _)) => {
                                            slice_eq(input, pos, "")
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
pub fn rust_type(input: &str) -> Result<(), ~str> {
    match parse_rust_type(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_expression(input: &str, pos: uint) -> Result<(uint, ~Expr) , uint> {
    parse_choice(input, pos)
}
pub fn expression(input: &str) -> Result<~Expr, ~str> {
    match parse_expression(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_choice(input: &str, pos: uint) -> Result<(uint, ~Expr) , uint> {
    let start_pos = pos;
    let seq_res = {
        parse_sequence(input, pos)
    };
    match seq_res {
        Err(pos) => Err(pos),
        Ok((pos, head)) => {
            let seq_res = {
                let mut repeat_pos = pos;
                let mut repeat_value = ~[];
                loop {
                    let step_res = {
                        let pos = repeat_pos;
                        let start_pos = pos;
                        let seq_res = {
                            parse_slash(input, pos)
                        };
                        match seq_res {
                            Err(pos) => Err(pos),
                            Ok((pos, _)) => {
                                let seq_res = {
                                    parse_sequence(input, pos)
                                };
                                match seq_res {
                                    Err(pos) => Err(pos),
                                    Ok((pos, s)) => {
                                        let match_str = input.slice(start_pos, pos);;
                                        Ok((pos, {s}))
                                    }
                                }
                            }
                        }
                    };
                    match step_res {
                        Ok((newpos, value)) => {
                            repeat_pos = newpos;
                            repeat_value.push(value);
                        }
                        Err(*) => {
                            break;
                        }
                    }
                }
                Ok((repeat_pos, repeat_value))
            };
            match seq_res {
                Err(pos) => Err(pos),
                Ok((pos, tail)) => {
                    let match_str = input.slice(start_pos, pos);;
                    Ok((pos, {
      if (tail.len() > 0) {
      	let mut list = tail;
      	list.unshift(head);
      	~ChoiceExpr(list)
      } else {
        head
      }
    }))
                }
            }
        }
    }
}
pub fn choice(input: &str) -> Result<~Expr, ~str> {
    match parse_choice(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_sequence(input: &str, pos: uint) -> Result<(uint, ~Expr) , uint> {
    let choice_res = {
        let start_pos = pos;
        let seq_res = {
            let mut repeat_pos = pos;
            let mut repeat_value = ~[];
            loop {
                let step_res = {
                    let pos = repeat_pos;
                    parse_labeled(input, pos)
                };
                match step_res {
                    Ok((newpos, value)) => {
                        repeat_pos = newpos;
                        repeat_value.push(value);
                    }
                    Err(*) => {
                        break;
                    }
                }
            }
            Ok((repeat_pos, repeat_value))
        };
        match seq_res {
            Err(pos) => Err(pos),
            Ok((pos, elements)) => {
                let seq_res = {
                    parse_action(input, pos)
                };
                match seq_res {
                    Err(pos) => Err(pos),
                    Ok((pos, code)) => {
                        let match_str = input.slice(start_pos, pos);;
                        Ok((pos, {
  	  ~ActionExpr(elements, code)
    }))
                    }
                }
            }
        }
    };
    match choice_res {
        Ok((pos, value)) => Ok((pos, value)),
        Err(*) => {
            let start_pos = pos;
            let seq_res = {
                let mut repeat_pos = pos;
                let mut repeat_value = ~[];
                loop {
                    let step_res = {
                        let pos = repeat_pos;
                        parse_prefixed(input, pos)
                    };
                    match step_res {
                        Ok((newpos, value)) => {
                            repeat_pos = newpos;
                            repeat_value.push(value);
                        }
                        Err(*) => {
                            break;
                        }
                    }
                }
                Ok((repeat_pos, repeat_value))
            };
            match seq_res {
                Err(pos) => Err(pos),
                Ok((pos, elements)) => {
                    let match_str = input.slice(start_pos, pos);;
                    Ok((pos, {
      if (elements.len() != 1) {
      	  ~SequenceExpr(elements)
      } else {
          elements[0]
      }
    }))
                }
            }
        }
    }
}
pub fn sequence(input: &str) -> Result<~Expr, ~str> {
    match parse_sequence(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_labeled(input: &str, pos: uint) -> Result<(uint, TaggedExpr) , uint> {
    let choice_res = {
        let start_pos = pos;
        let seq_res = {
            parse_identifier(input, pos)
        };
        match seq_res {
            Err(pos) => Err(pos),
            Ok((pos, label)) => {
                let seq_res = {
                    parse_colon(input, pos)
                };
                match seq_res {
                    Err(pos) => Err(pos),
                    Ok((pos, _)) => {
                        let seq_res = {
                            parse_prefixed(input, pos)
                        };
                        match seq_res {
                            Err(pos) => Err(pos),
                            Ok((pos, expression)) => {
                                let match_str = input.slice(start_pos, pos);;
                                Ok((pos, {
      TaggedExpr{ name: Some(label), expr: expression }
    }))
                            }
                        }
                    }
                }
            }
        }
    };
    match choice_res {
        Ok((pos, value)) => Ok((pos, value)),
        Err(*) => {
            let start_pos = pos;
            let seq_res = {
                parse_prefixed(input, pos)
            };
            match seq_res {
                Err(pos) => Err(pos),
                Ok((pos, expr)) => {
                    let match_str = input.slice(start_pos, pos);;
                    Ok((pos, {
      TaggedExpr{ name: None, expr: expr }
  }))
                }
            }
        }
    }
}
pub fn labeled(input: &str) -> Result<TaggedExpr, ~str> {
    match parse_labeled(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_prefixed(input: &str, pos: uint) -> Result<(uint, ~Expr) , uint> {
    let choice_res = {
        let start_pos = pos;
        let seq_res = {
            parse_dollar(input, pos)
        };
        match seq_res {
            Err(pos) => Err(pos),
            Ok((pos, _)) => {
                let seq_res = {
                    parse_suffixed(input, pos)
                };
                match seq_res {
                    Err(pos) => Err(pos),
                    Ok((pos, expression)) => {
                        let match_str = input.slice(start_pos, pos);;
                        Ok((pos, {
      expression
    }))
                    }
                }
            }
        }
    };
    match choice_res {
        Ok((pos, value)) => Ok((pos, value)),
        Err(*) => {
            let choice_res = {
                let start_pos = pos;
                let seq_res = {
                    parse_and(input, pos)
                };
                match seq_res {
                    Err(pos) => Err(pos),
                    Ok((pos, _)) => {
                        let seq_res = {
                            parse_suffixed(input, pos)
                        };
                        match seq_res {
                            Err(pos) => Err(pos),
                            Ok((pos, expression)) => {
                                let match_str = input.slice(start_pos, pos);;
                                Ok((pos, {
      ~PosAssertExpr(expression)
    }))
                            }
                        }
                    }
                }
            };
            match choice_res {
                Ok((pos, value)) => Ok((pos, value)),
                Err(*) => {
                    let choice_res = {
                        let start_pos = pos;
                        let seq_res = {
                            parse_not(input, pos)
                        };
                        match seq_res {
                            Err(pos) => Err(pos),
                            Ok((pos, _)) => {
                                let seq_res = {
                                    parse_suffixed(input, pos)
                                };
                                match seq_res {
                                    Err(pos) => Err(pos),
                                    Ok((pos, expression)) => {
                                        let match_str = input.slice(start_pos, pos);;
                                        Ok((pos, {
      ~NegAssertExpr(expression)
    }))
                                    }
                                }
                            }
                        }
                    };
                    match choice_res {
                        Ok((pos, value)) => Ok((pos, value)),
                        Err(*) => {
                            parse_suffixed(input, pos)
                        }
                    }
                }
            }
        }
    }
}
pub fn prefixed(input: &str) -> Result<~Expr, ~str> {
    match parse_prefixed(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_suffixed(input: &str, pos: uint) -> Result<(uint, ~Expr) , uint> {
    let choice_res = {
        let start_pos = pos;
        let seq_res = {
            parse_primary(input, pos)
        };
        match seq_res {
            Err(pos) => Err(pos),
            Ok((pos, expression)) => {
                let seq_res = {
                    parse_question(input, pos)
                };
                match seq_res {
                    Err(pos) => Err(pos),
                    Ok((pos, _)) => {
                        let match_str = input.slice(start_pos, pos);;
                        Ok((pos, {
       ~OptionalExpr(expression)
    }))
                    }
                }
            }
        }
    };
    match choice_res {
        Ok((pos, value)) => Ok((pos, value)),
        Err(*) => {
            let choice_res = {
                let start_pos = pos;
                let seq_res = {
                    parse_primary(input, pos)
                };
                match seq_res {
                    Err(pos) => Err(pos),
                    Ok((pos, expression)) => {
                        let seq_res = {
                            parse_star(input, pos)
                        };
                        match seq_res {
                            Err(pos) => Err(pos),
                            Ok((pos, _)) => {
                                let match_str = input.slice(start_pos, pos);;
                                Ok((pos, {
    	~ZeroOrMore(expression)
    }))
                            }
                        }
                    }
                }
            };
            match choice_res {
                Ok((pos, value)) => Ok((pos, value)),
                Err(*) => {
                    let choice_res = {
                        let start_pos = pos;
                        let seq_res = {
                            parse_primary(input, pos)
                        };
                        match seq_res {
                            Err(pos) => Err(pos),
                            Ok((pos, expression)) => {
                                let seq_res = {
                                    parse_plus(input, pos)
                                };
                                match seq_res {
                                    Err(pos) => Err(pos),
                                    Ok((pos, _)) => {
                                        let match_str = input.slice(start_pos, pos);;
                                        Ok((pos, {
    	~OneOrMore(expression)
    }))
                                    }
                                }
                            }
                        }
                    };
                    match choice_res {
                        Ok((pos, value)) => Ok((pos, value)),
                        Err(*) => {
                            parse_primary(input, pos)
                        }
                    }
                }
            }
        }
    }
}
pub fn suffixed(input: &str) -> Result<~Expr, ~str> {
    match parse_suffixed(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_primary(input: &str, pos: uint) -> Result<(uint, ~Expr) , uint> {
    let choice_res = {
        let start_pos = pos;
        let seq_res = {
            parse_identifier(input, pos)
        };
        match seq_res {
            Err(pos) => Err(pos),
            Ok((pos, name)) => {
                let seq_res = {
                    let neg_assert_res = {
                        let seq_res = {
                            let optional_res = {
                                parse_string(input, pos)
                            };
                            match optional_res {
                                Ok((newpos, value)) => Ok((newpos, Some(value))),
                                Err(*) => Ok((pos, None)),
                            }
                        };
                        match seq_res {
                            Err(pos) => Err(pos),
                            Ok((pos, _)) => {
                                let seq_res = {
                                    parse_returntype(input, pos)
                                };
                                match seq_res {
                                    Err(pos) => Err(pos),
                                    Ok((pos, _)) => {
                                        parse_equals(input, pos)
                                    }
                                }
                            }
                        }
                    };
                    match neg_assert_res {
                        Err(*) => Ok((pos, ())),
                        Ok(*) => Err(pos),
                    }
                };
                match seq_res {
                    Err(pos) => Err(pos),
                    Ok((pos, _)) => {
                        let match_str = input.slice(start_pos, pos);;
                        Ok((pos, {
      ~RuleExpr(name)
    }))
                    }
                }
            }
        }
    };
    match choice_res {
        Ok((pos, value)) => Ok((pos, value)),
        Err(*) => {
            let choice_res = {
                parse_literal(input, pos)
            };
            match choice_res {
                Ok((pos, value)) => Ok((pos, value)),
                Err(*) => {
                    let choice_res = {
                        parse_class(input, pos)
                    };
                    match choice_res {
                        Ok((pos, value)) => Ok((pos, value)),
                        Err(*) => {
                            let choice_res = {
                                let start_pos = pos;
                                let seq_res = {
                                    parse_dot(input, pos)
                                };
                                match seq_res {
                                    Err(pos) => Err(pos),
                                    Ok((pos, _)) => {
                                        let match_str = input.slice(start_pos, pos);;
                                        Ok((pos, { ~AnyCharExpr }))
                                    }
                                }
                            };
                            match choice_res {
                                Ok((pos, value)) => Ok((pos, value)),
                                Err(*) => {
                                    let start_pos = pos;
                                    let seq_res = {
                                        parse_lparen(input, pos)
                                    };
                                    match seq_res {
                                        Err(pos) => Err(pos),
                                        Ok((pos, _)) => {
                                            let seq_res = {
                                                parse_expression(input, pos)
                                            };
                                            match seq_res {
                                                Err(pos) => Err(pos),
                                                Ok((pos, expression)) => {
                                                    let seq_res = {
                                                        parse_rparen(input, pos)
                                                    };
                                                    match seq_res {
                                                        Err(pos) => Err(pos),
                                                        Ok((pos, _)) => {
                                                            let match_str = input.slice(start_pos, pos);;
                                                            Ok((pos, { expression }))
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
pub fn primary(input: &str) -> Result<~Expr, ~str> {
    match parse_primary(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_action(input: &str, pos: uint) -> Result<(uint, ~str) , uint> {
    let start_pos = pos;
    let seq_res = {
        parse_braced(input, pos)
    };
    match seq_res {
        Err(pos) => Err(pos),
        Ok((pos, braced)) => {
            let seq_res = {
                parse___(input, pos)
            };
            match seq_res {
                Err(pos) => Err(pos),
                Ok((pos, _)) => {
                    let match_str = input.slice(start_pos, pos);;
                    Ok((pos, { braced }))
                }
            }
        }
    }
}
pub fn action(input: &str) -> Result<~str, ~str> {
    match parse_action(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_braced(input: &str, pos: uint) -> Result<(uint, ~str) , uint> {
    let start_pos = pos;
    let seq_res = {
        slice_eq(input, pos, "{")
    };
    match seq_res {
        Err(pos) => Err(pos),
        Ok((pos, _)) => {
            let seq_res = {
                let start_pos = pos;
                let seq_res = {
                    let mut repeat_pos = pos;
                    loop {
                        let step_res = {
                            let pos = repeat_pos;
                            let choice_res = {
                                let seq_res = {
                                    parse_braced(input, pos)
                                };
                                match seq_res {
                                    Err(pos) => Err(pos),
                                    Ok((pos, _)) => {
                                        slice_eq(input, pos, "")
                                    }
                                }
                            };
                            match choice_res {
                                Ok((pos, value)) => Ok((pos, value)),
                                Err(*) => {
                                    parse_nonBraceCharacters(input, pos)
                                }
                            }
                        };
                        match step_res {
                            Ok((newpos, _)) => {
                                repeat_pos = newpos;
                            }
                            Err(*) => {
                                break;
                            }
                        }
                    }
                    Ok((repeat_pos, ()))
                };
                match seq_res {
                    Err(pos) => Err(pos),
                    Ok((pos, _)) => {
                        let match_str = input.slice(start_pos, pos);;
                        Ok((pos, {match_str.to_owned()}))
                    }
                }
            };
            match seq_res {
                Err(pos) => Err(pos),
                Ok((pos, b)) => {
                    let seq_res = {
                        slice_eq(input, pos, "}")
                    };
                    match seq_res {
                        Err(pos) => Err(pos),
                        Ok((pos, _)) => {
                            let match_str = input.slice(start_pos, pos);;
                            Ok((pos, {b}))
                        }
                    }
                }
            }
        }
    }
}
pub fn braced(input: &str) -> Result<~str, ~str> {
    match parse_braced(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_nonBraceCharacters(input: &str, pos: uint) -> Result<(uint, ()) , uint> {
    let seq_res = {
        parse_nonBraceCharacter(input, pos)
    };
    match seq_res {
        Err(pos) => Err(pos),
        Ok((pos, _)) => {
            let mut repeat_pos = pos;
            loop {
                let step_res = {
                    let pos = repeat_pos;
                    parse_nonBraceCharacter(input, pos)
                };
                match step_res {
                    Ok((newpos, _)) => {
                        repeat_pos = newpos;
                    }
                    Err(*) => {
                        break;
                    }
                }
            }
            Ok((repeat_pos, ()))
        }
    }
}
pub fn nonBraceCharacters(input: &str) -> Result<(), ~str> {
    match parse_nonBraceCharacters(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_nonBraceCharacter(input: &str, pos: uint) -> Result<(uint, ()) , uint> {
    if input.len() > pos {
        let CharRange {ch, next} = input.char_range_at(pos);
        match ch {
            '{' | '}' => { Err(pos) }
            _ => Ok((next, ())),
        }
    } else {
        Err(pos)
    }
}
pub fn nonBraceCharacter(input: &str) -> Result<(), ~str> {
    match parse_nonBraceCharacter(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_equals(input: &str, pos: uint) -> Result<(uint, ()) , uint> {
    let seq_res = {
        slice_eq(input, pos, "=")
    };
    match seq_res {
        Err(pos) => Err(pos),
        Ok((pos, _)) => {
            parse___(input, pos)
        }
    }
}
pub fn equals(input: &str) -> Result<(), ~str> {
    match parse_equals(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_colon(input: &str, pos: uint) -> Result<(uint, ()) , uint> {
    let seq_res = {
        slice_eq(input, pos, ":")
    };
    match seq_res {
        Err(pos) => Err(pos),
        Ok((pos, _)) => {
            parse___(input, pos)
        }
    }
}
pub fn colon(input: &str) -> Result<(), ~str> {
    match parse_colon(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_semicolon(input: &str, pos: uint) -> Result<(uint, ()) , uint> {
    let seq_res = {
        slice_eq(input, pos, ";")
    };
    match seq_res {
        Err(pos) => Err(pos),
        Ok((pos, _)) => {
            parse___(input, pos)
        }
    }
}
pub fn semicolon(input: &str) -> Result<(), ~str> {
    match parse_semicolon(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_slash(input: &str, pos: uint) -> Result<(uint, ()) , uint> {
    let seq_res = {
        slice_eq(input, pos, "/")
    };
    match seq_res {
        Err(pos) => Err(pos),
        Ok((pos, _)) => {
            parse___(input, pos)
        }
    }
}
pub fn slash(input: &str) -> Result<(), ~str> {
    match parse_slash(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_and(input: &str, pos: uint) -> Result<(uint, ()) , uint> {
    let seq_res = {
        slice_eq(input, pos, "&")
    };
    match seq_res {
        Err(pos) => Err(pos),
        Ok((pos, _)) => {
            parse___(input, pos)
        }
    }
}
pub fn and(input: &str) -> Result<(), ~str> {
    match parse_and(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_not(input: &str, pos: uint) -> Result<(uint, ()) , uint> {
    let seq_res = {
        slice_eq(input, pos, "!")
    };
    match seq_res {
        Err(pos) => Err(pos),
        Ok((pos, _)) => {
            parse___(input, pos)
        }
    }
}
pub fn not(input: &str) -> Result<(), ~str> {
    match parse_not(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_dollar(input: &str, pos: uint) -> Result<(uint, ()) , uint> {
    let seq_res = {
        slice_eq(input, pos, "$")
    };
    match seq_res {
        Err(pos) => Err(pos),
        Ok((pos, _)) => {
            parse___(input, pos)
        }
    }
}
pub fn dollar(input: &str) -> Result<(), ~str> {
    match parse_dollar(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_question(input: &str, pos: uint) -> Result<(uint, ()) , uint> {
    let seq_res = {
        slice_eq(input, pos, "?")
    };
    match seq_res {
        Err(pos) => Err(pos),
        Ok((pos, _)) => {
            parse___(input, pos)
        }
    }
}
pub fn question(input: &str) -> Result<(), ~str> {
    match parse_question(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_star(input: &str, pos: uint) -> Result<(uint, ()) , uint> {
    let seq_res = {
        slice_eq(input, pos, "*")
    };
    match seq_res {
        Err(pos) => Err(pos),
        Ok((pos, _)) => {
            parse___(input, pos)
        }
    }
}
pub fn star(input: &str) -> Result<(), ~str> {
    match parse_star(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_plus(input: &str, pos: uint) -> Result<(uint, ()) , uint> {
    let seq_res = {
        slice_eq(input, pos, "+")
    };
    match seq_res {
        Err(pos) => Err(pos),
        Ok((pos, _)) => {
            parse___(input, pos)
        }
    }
}
pub fn plus(input: &str) -> Result<(), ~str> {
    match parse_plus(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_lparen(input: &str, pos: uint) -> Result<(uint, ()) , uint> {
    let seq_res = {
        slice_eq(input, pos, "(")
    };
    match seq_res {
        Err(pos) => Err(pos),
        Ok((pos, _)) => {
            parse___(input, pos)
        }
    }
}
pub fn lparen(input: &str) -> Result<(), ~str> {
    match parse_lparen(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_rparen(input: &str, pos: uint) -> Result<(uint, ()) , uint> {
    let seq_res = {
        slice_eq(input, pos, ")")
    };
    match seq_res {
        Err(pos) => Err(pos),
        Ok((pos, _)) => {
            parse___(input, pos)
        }
    }
}
pub fn rparen(input: &str) -> Result<(), ~str> {
    match parse_rparen(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_dot(input: &str, pos: uint) -> Result<(uint, ()) , uint> {
    let seq_res = {
        slice_eq(input, pos, ".")
    };
    match seq_res {
        Err(pos) => Err(pos),
        Ok((pos, _)) => {
            parse___(input, pos)
        }
    }
}
pub fn dot(input: &str) -> Result<(), ~str> {
    match parse_dot(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_returns(input: &str, pos: uint) -> Result<(uint, ()) , uint> {
    let seq_res = {
        slice_eq(input, pos, "->")
    };
    match seq_res {
        Err(pos) => Err(pos),
        Ok((pos, _)) => {
            parse___(input, pos)
        }
    }
}
pub fn returns(input: &str) -> Result<(), ~str> {
    match parse_returns(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_identifier(input: &str, pos: uint) -> Result<(uint, ~str) , uint> {
    let start_pos = pos;
    let seq_res = {
        let start_pos = pos;
        let seq_res = {
            let choice_res = {
                parse_letter(input, pos)
            };
            match choice_res {
                Ok((pos, value)) => Ok((pos, value)),
                Err(*) => {
                    slice_eq(input, pos, "_")
                }
            }
        };
        match seq_res {
            Err(pos) => Err(pos),
            Ok((pos, _)) => {
                let seq_res = {
                    let mut repeat_pos = pos;
                    loop {
                        let step_res = {
                            let pos = repeat_pos;
                            let choice_res = {
                                parse_letter(input, pos)
                            };
                            match choice_res {
                                Ok((pos, value)) => Ok((pos, value)),
                                Err(*) => {
                                    let choice_res = {
                                        parse_digit(input, pos)
                                    };
                                    match choice_res {
                                        Ok((pos, value)) => Ok((pos, value)),
                                        Err(*) => {
                                            slice_eq(input, pos, "_")
                                        }
                                    }
                                }
                            }
                        };
                        match step_res {
                            Ok((newpos, _)) => {
                                repeat_pos = newpos;
                            }
                            Err(*) => {
                                break;
                            }
                        }
                    }
                    Ok((repeat_pos, ()))
                };
                match seq_res {
                    Err(pos) => Err(pos),
                    Ok((pos, _)) => {
                        let match_str = input.slice(start_pos, pos);;
                        Ok((pos, {match_str.to_owned()}))
                    }
                }
            }
        }
    };
    match seq_res {
        Err(pos) => Err(pos),
        Ok((pos, chars)) => {
            let seq_res = {
                parse___(input, pos)
            };
            match seq_res {
                Err(pos) => Err(pos),
                Ok((pos, _)) => {
                    let match_str = input.slice(start_pos, pos);;
                    Ok((pos, { chars }))
                }
            }
        }
    }
}
pub fn identifier(input: &str) -> Result<~str, ~str> {
    match parse_identifier(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_literal(input: &str, pos: uint) -> Result<(uint, ~Expr) , uint> {
    let start_pos = pos;
    let seq_res = {
        let choice_res = {
            parse_doubleQuotedString(input, pos)
        };
        match choice_res {
            Ok((pos, value)) => Ok((pos, value)),
            Err(*) => {
                parse_singleQuotedString(input, pos)
            }
        }
    };
    match seq_res {
        Err(pos) => Err(pos),
        Ok((pos, value)) => {
            let seq_res = {
                let optional_res = {
                    slice_eq(input, pos, "i")
                };
                match optional_res {
                    Ok((newpos, value)) => Ok((newpos, Some(value))),
                    Err(*) => Ok((pos, None)),
                }
            };
            match seq_res {
                Err(pos) => Err(pos),
                Ok((pos, flags)) => {
                    let seq_res = {
                        parse___(input, pos)
                    };
                    match seq_res {
                        Err(pos) => Err(pos),
                        Ok((pos, _)) => {
                            let match_str = input.slice(start_pos, pos);;
                            Ok((pos, {
    	~LiteralExpr(value)
    }))
                        }
                    }
                }
            }
        }
    }
}
pub fn literal(input: &str) -> Result<~Expr, ~str> {
    match parse_literal(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_string(input: &str, pos: uint) -> Result<(uint, ~str) , uint> {
    let start_pos = pos;
    let seq_res = {
        let choice_res = {
            parse_doubleQuotedString(input, pos)
        };
        match choice_res {
            Ok((pos, value)) => Ok((pos, value)),
            Err(*) => {
                parse_singleQuotedString(input, pos)
            }
        }
    };
    match seq_res {
        Err(pos) => Err(pos),
        Ok((pos, string)) => {
            let seq_res = {
                parse___(input, pos)
            };
            match seq_res {
                Err(pos) => Err(pos),
                Ok((pos, _)) => {
                    let match_str = input.slice(start_pos, pos);;
                    Ok((pos, { string }))
                }
            }
        }
    }
}
pub fn string(input: &str) -> Result<~str, ~str> {
    match parse_string(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_doubleQuotedString(input: &str, pos: uint) -> Result<(uint, ~str) , uint> {
    let start_pos = pos;
    let seq_res = {
        slice_eq(input, pos, "\"")
    };
    match seq_res {
        Err(pos) => Err(pos),
        Ok((pos, _)) => {
            let seq_res = {
                let mut repeat_pos = pos;
                let mut repeat_value = ~[];
                loop {
                    let step_res = {
                        let pos = repeat_pos;
                        parse_doubleQuotedCharacter(input, pos)
                    };
                    match step_res {
                        Ok((newpos, value)) => {
                            repeat_pos = newpos;
                            repeat_value.push(value);
                        }
                        Err(*) => {
                            break;
                        }
                    }
                }
                Ok((repeat_pos, repeat_value))
            };
            match seq_res {
                Err(pos) => Err(pos),
                Ok((pos, s)) => {
                    let seq_res = {
                        slice_eq(input, pos, "\"")
                    };
                    match seq_res {
                        Err(pos) => Err(pos),
                        Ok((pos, _)) => {
                            let match_str = input.slice(start_pos, pos);;
                            Ok((pos, { std::str::from_chars(s) }))
                        }
                    }
                }
            }
        }
    }
}
pub fn doubleQuotedString(input: &str) -> Result<~str, ~str> {
    match parse_doubleQuotedString(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_doubleQuotedCharacter(input: &str, pos: uint) -> Result<(uint, char) , uint> {
    let choice_res = {
        parse_simpleDoubleQuotedCharacter(input, pos)
    };
    match choice_res {
        Ok((pos, value)) => Ok((pos, value)),
        Err(*) => {
            let choice_res = {
                parse_simpleEscapeSequence(input, pos)
            };
            match choice_res {
                Ok((pos, value)) => Ok((pos, value)),
                Err(*) => {
                    let choice_res = {
                        parse_zeroEscapeSequence(input, pos)
                    };
                    match choice_res {
                        Ok((pos, value)) => Ok((pos, value)),
                        Err(*) => {
                            let choice_res = {
                                parse_hexEscapeSequence(input, pos)
                            };
                            match choice_res {
                                Ok((pos, value)) => Ok((pos, value)),
                                Err(*) => {
                                    let choice_res = {
                                        parse_unicodeEscapeSequence(input, pos)
                                    };
                                    match choice_res {
                                        Ok((pos, value)) => Ok((pos, value)),
                                        Err(*) => {
                                            parse_eolEscapeSequence(input, pos)
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
pub fn doubleQuotedCharacter(input: &str) -> Result<char, ~str> {
    match parse_doubleQuotedCharacter(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_simpleDoubleQuotedCharacter(input: &str, pos: uint) -> Result<(uint, char) , uint> {
    let start_pos = pos;
    let seq_res = {
        let neg_assert_res = {
            let choice_res = {
                slice_eq(input, pos, "\"")
            };
            match choice_res {
                Ok((pos, value)) => Ok((pos, value)),
                Err(*) => {
                    let choice_res = {
                        slice_eq(input, pos, "\\")
                    };
                    match choice_res {
                        Ok((pos, value)) => Ok((pos, value)),
                        Err(*) => {
                            parse_eolChar(input, pos)
                        }
                    }
                }
            }
        };
        match neg_assert_res {
            Err(*) => Ok((pos, ())),
            Ok(*) => Err(pos),
        }
    };
    match seq_res {
        Err(pos) => Err(pos),
        Ok((pos, _)) => {
            let seq_res = {
                any_char(input, pos)
            };
            match seq_res {
                Err(pos) => Err(pos),
                Ok((pos, _)) => {
                    let match_str = input.slice(start_pos, pos);;
                    Ok((pos, { match_str.char_at(0) }))
                }
            }
        }
    }
}
pub fn simpleDoubleQuotedCharacter(input: &str) -> Result<char, ~str> {
    match parse_simpleDoubleQuotedCharacter(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_singleQuotedString(input: &str, pos: uint) -> Result<(uint, ~str) , uint> {
    let start_pos = pos;
    let seq_res = {
        slice_eq(input, pos, "\'")
    };
    match seq_res {
        Err(pos) => Err(pos),
        Ok((pos, _)) => {
            let seq_res = {
                let mut repeat_pos = pos;
                let mut repeat_value = ~[];
                loop {
                    let step_res = {
                        let pos = repeat_pos;
                        parse_singleQuotedCharacter(input, pos)
                    };
                    match step_res {
                        Ok((newpos, value)) => {
                            repeat_pos = newpos;
                            repeat_value.push(value);
                        }
                        Err(*) => {
                            break;
                        }
                    }
                }
                Ok((repeat_pos, repeat_value))
            };
            match seq_res {
                Err(pos) => Err(pos),
                Ok((pos, s)) => {
                    let seq_res = {
                        slice_eq(input, pos, "\'")
                    };
                    match seq_res {
                        Err(pos) => Err(pos),
                        Ok((pos, _)) => {
                            let match_str = input.slice(start_pos, pos);;
                            Ok((pos, { std::str::from_chars(s) }))
                        }
                    }
                }
            }
        }
    }
}
pub fn singleQuotedString(input: &str) -> Result<~str, ~str> {
    match parse_singleQuotedString(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_singleQuotedCharacter(input: &str, pos: uint) -> Result<(uint, char) , uint> {
    let choice_res = {
        parse_simpleSingleQuotedCharacter(input, pos)
    };
    match choice_res {
        Ok((pos, value)) => Ok((pos, value)),
        Err(*) => {
            let choice_res = {
                parse_simpleEscapeSequence(input, pos)
            };
            match choice_res {
                Ok((pos, value)) => Ok((pos, value)),
                Err(*) => {
                    let choice_res = {
                        parse_zeroEscapeSequence(input, pos)
                    };
                    match choice_res {
                        Ok((pos, value)) => Ok((pos, value)),
                        Err(*) => {
                            let choice_res = {
                                parse_hexEscapeSequence(input, pos)
                            };
                            match choice_res {
                                Ok((pos, value)) => Ok((pos, value)),
                                Err(*) => {
                                    let choice_res = {
                                        parse_unicodeEscapeSequence(input, pos)
                                    };
                                    match choice_res {
                                        Ok((pos, value)) => Ok((pos, value)),
                                        Err(*) => {
                                            parse_eolEscapeSequence(input, pos)
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
pub fn singleQuotedCharacter(input: &str) -> Result<char, ~str> {
    match parse_singleQuotedCharacter(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_simpleSingleQuotedCharacter(input: &str, pos: uint) -> Result<(uint, char) , uint> {
    let start_pos = pos;
    let seq_res = {
        let neg_assert_res = {
            let choice_res = {
                slice_eq(input, pos, "\'")
            };
            match choice_res {
                Ok((pos, value)) => Ok((pos, value)),
                Err(*) => {
                    let choice_res = {
                        slice_eq(input, pos, "\\")
                    };
                    match choice_res {
                        Ok((pos, value)) => Ok((pos, value)),
                        Err(*) => {
                            parse_eolChar(input, pos)
                        }
                    }
                }
            }
        };
        match neg_assert_res {
            Err(*) => Ok((pos, ())),
            Ok(*) => Err(pos),
        }
    };
    match seq_res {
        Err(pos) => Err(pos),
        Ok((pos, _)) => {
            let seq_res = {
                any_char(input, pos)
            };
            match seq_res {
                Err(pos) => Err(pos),
                Ok((pos, _)) => {
                    let match_str = input.slice(start_pos, pos);;
                    Ok((pos, { match_str.char_at(0) }))
                }
            }
        }
    }
}
pub fn simpleSingleQuotedCharacter(input: &str) -> Result<char, ~str> {
    match parse_simpleSingleQuotedCharacter(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_class(input: &str, pos: uint) -> Result<(uint, ~Expr) , uint> {
    let start_pos = pos;
    let seq_res = {
        slice_eq(input, pos, "[")
    };
    match seq_res {
        Err(pos) => Err(pos),
        Ok((pos, _)) => {
            let seq_res = {
                let optional_res = {
                    slice_eq(input, pos, "^")
                };
                match optional_res {
                    Ok((newpos, value)) => Ok((newpos, Some(value))),
                    Err(*) => Ok((pos, None)),
                }
            };
            match seq_res {
                Err(pos) => Err(pos),
                Ok((pos, inverted)) => {
                    let seq_res = {
                        let mut repeat_pos = pos;
                        let mut repeat_value = ~[];
                        loop {
                            let step_res = {
                                let pos = repeat_pos;
                                let choice_res = {
                                    parse_classCharacterRange(input, pos)
                                };
                                match choice_res {
                                    Ok((pos, value)) => Ok((pos, value)),
                                    Err(*) => {
                                        parse_classCharacter(input, pos)
                                    }
                                }
                            };
                            match step_res {
                                Ok((newpos, value)) => {
                                    repeat_pos = newpos;
                                    repeat_value.push(value);
                                }
                                Err(*) => {
                                    break;
                                }
                            }
                        }
                        Ok((repeat_pos, repeat_value))
                    };
                    match seq_res {
                        Err(pos) => Err(pos),
                        Ok((pos, parts)) => {
                            let seq_res = {
                                slice_eq(input, pos, "]")
                            };
                            match seq_res {
                                Err(pos) => Err(pos),
                                Ok((pos, _)) => {
                                    let seq_res = {
                                        let optional_res = {
                                            slice_eq(input, pos, "i")
                                        };
                                        match optional_res {
                                            Ok((newpos, value)) => Ok((newpos, Some(value))),
                                            Err(*) => Ok((pos, None)),
                                        }
                                    };
                                    match seq_res {
                                        Err(pos) => Err(pos),
                                        Ok((pos, flags)) => {
                                            let seq_res = {
                                                parse___(input, pos)
                                            };
                                            match seq_res {
                                                Err(pos) => Err(pos),
                                                Ok((pos, _)) => {
                                                    let match_str = input.slice(start_pos, pos);;
                                                    Ok((pos, {
      ~CharSetExpr(inverted.is_some(), parts)
    }))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
pub fn class(input: &str) -> Result<~Expr, ~str> {
    match parse_class(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_classCharacterRange(input: &str, pos: uint) -> Result<(uint, CharSetCase) , uint> {
    let start_pos = pos;
    let seq_res = {
        parse_bracketDelimitedCharacter(input, pos)
    };
    match seq_res {
        Err(pos) => Err(pos),
        Ok((pos, begin)) => {
            let seq_res = {
                slice_eq(input, pos, "-")
            };
            match seq_res {
                Err(pos) => Err(pos),
                Ok((pos, _)) => {
                    let seq_res = {
                        parse_bracketDelimitedCharacter(input, pos)
                    };
                    match seq_res {
                        Err(pos) => Err(pos),
                        Ok((pos, end)) => {
                            let match_str = input.slice(start_pos, pos);;
                            Ok((pos, {
  		//TODO: check start > end
  		CharSetCase{start:begin, end:end}
    }))
                        }
                    }
                }
            }
        }
    }
}
pub fn classCharacterRange(input: &str) -> Result<CharSetCase, ~str> {
    match parse_classCharacterRange(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_classCharacter(input: &str, pos: uint) -> Result<(uint, CharSetCase) , uint> {
    let start_pos = pos;
    let seq_res = {
        parse_bracketDelimitedCharacter(input, pos)
    };
    match seq_res {
        Err(pos) => Err(pos),
        Ok((pos, char_)) => {
            let match_str = input.slice(start_pos, pos);;
            Ok((pos, {
  		CharSetCase{start:char_, end:char_}
    }))
        }
    }
}
pub fn classCharacter(input: &str) -> Result<CharSetCase, ~str> {
    match parse_classCharacter(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_bracketDelimitedCharacter(input: &str, pos: uint) -> Result<(uint, char) , uint> {
    let choice_res = {
        parse_simpleBracketDelimitedCharacter(input, pos)
    };
    match choice_res {
        Ok((pos, value)) => Ok((pos, value)),
        Err(*) => {
            let choice_res = {
                parse_simpleEscapeSequence(input, pos)
            };
            match choice_res {
                Ok((pos, value)) => Ok((pos, value)),
                Err(*) => {
                    let choice_res = {
                        parse_zeroEscapeSequence(input, pos)
                    };
                    match choice_res {
                        Ok((pos, value)) => Ok((pos, value)),
                        Err(*) => {
                            let choice_res = {
                                parse_hexEscapeSequence(input, pos)
                            };
                            match choice_res {
                                Ok((pos, value)) => Ok((pos, value)),
                                Err(*) => {
                                    let choice_res = {
                                        parse_unicodeEscapeSequence(input, pos)
                                    };
                                    match choice_res {
                                        Ok((pos, value)) => Ok((pos, value)),
                                        Err(*) => {
                                            parse_eolEscapeSequence(input, pos)
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
pub fn bracketDelimitedCharacter(input: &str) -> Result<char, ~str> {
    match parse_bracketDelimitedCharacter(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_simpleBracketDelimitedCharacter(input: &str, pos: uint) -> Result<(uint, char) , uint> {
    let start_pos = pos;
    let seq_res = {
        let neg_assert_res = {
            let choice_res = {
                slice_eq(input, pos, "]")
            };
            match choice_res {
                Ok((pos, value)) => Ok((pos, value)),
                Err(*) => {
                    let choice_res = {
                        slice_eq(input, pos, "\\")
                    };
                    match choice_res {
                        Ok((pos, value)) => Ok((pos, value)),
                        Err(*) => {
                            parse_eolChar(input, pos)
                        }
                    }
                }
            }
        };
        match neg_assert_res {
            Err(*) => Ok((pos, ())),
            Ok(*) => Err(pos),
        }
    };
    match seq_res {
        Err(pos) => Err(pos),
        Ok((pos, _)) => {
            let seq_res = {
                any_char(input, pos)
            };
            match seq_res {
                Err(pos) => Err(pos),
                Ok((pos, _)) => {
                    let match_str = input.slice(start_pos, pos);;
                    Ok((pos, { match_str.char_at(0) }))
                }
            }
        }
    }
}
pub fn simpleBracketDelimitedCharacter(input: &str) -> Result<char, ~str> {
    match parse_simpleBracketDelimitedCharacter(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_simpleEscapeSequence(input: &str, pos: uint) -> Result<(uint, char) , uint> {
    let start_pos = pos;
    let seq_res = {
        slice_eq(input, pos, "\\")
    };
    match seq_res {
        Err(pos) => Err(pos),
        Ok((pos, _)) => {
            let seq_res = {
                let neg_assert_res = {
                    let choice_res = {
                        parse_digit(input, pos)
                    };
                    match choice_res {
                        Ok((pos, value)) => Ok((pos, value)),
                        Err(*) => {
                            let choice_res = {
                                slice_eq(input, pos, "x")
                            };
                            match choice_res {
                                Ok((pos, value)) => Ok((pos, value)),
                                Err(*) => {
                                    let choice_res = {
                                        slice_eq(input, pos, "u")
                                    };
                                    match choice_res {
                                        Ok((pos, value)) => Ok((pos, value)),
                                        Err(*) => {
                                            parse_eolChar(input, pos)
                                        }
                                    }
                                }
                            }
                        }
                    }
                };
                match neg_assert_res {
                    Err(*) => Ok((pos, ())),
                    Ok(*) => Err(pos),
                }
            };
            match seq_res {
                Err(pos) => Err(pos),
                Ok((pos, _)) => {
                    let seq_res = {
                        any_char(input, pos)
                    };
                    match seq_res {
                        Err(pos) => Err(pos),
                        Ok((pos, _)) => {
                            let match_str = input.slice(start_pos, pos);;
                            Ok((pos, {
  		match match_str.char_at(1) {
  			//'b' => '\b',
  			//'f' => '\f',
  			'n' => '\n',
  			'r' => '\r',
  			't' => '\t',
  			//'v' => '\v',
  			 x  => x
  		}
    }))
                        }
                    }
                }
            }
        }
    }
}
pub fn simpleEscapeSequence(input: &str) -> Result<char, ~str> {
    match parse_simpleEscapeSequence(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_zeroEscapeSequence(input: &str, pos: uint) -> Result<(uint, char) , uint> {
    let start_pos = pos;
    let seq_res = {
        slice_eq(input, pos, "\\0")
    };
    match seq_res {
        Err(pos) => Err(pos),
        Ok((pos, _)) => {
            let seq_res = {
                let neg_assert_res = {
                    parse_digit(input, pos)
                };
                match neg_assert_res {
                    Err(*) => Ok((pos, ())),
                    Ok(*) => Err(pos),
                }
            };
            match seq_res {
                Err(pos) => Err(pos),
                Ok((pos, _)) => {
                    let match_str = input.slice(start_pos, pos);;
                    Ok((pos, { 0u8 as char }))
                }
            }
        }
    }
}
pub fn zeroEscapeSequence(input: &str) -> Result<char, ~str> {
    match parse_zeroEscapeSequence(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_hexEscapeSequence(input: &str, pos: uint) -> Result<(uint, char) , uint> {
    let start_pos = pos;
    let seq_res = {
        slice_eq(input, pos, "\\x")
    };
    match seq_res {
        Err(pos) => Err(pos),
        Ok((pos, _)) => {
            let seq_res = {
                let start_pos = pos;
                let seq_res = {
                    parse_hexDigit(input, pos)
                };
                match seq_res {
                    Err(pos) => Err(pos),
                    Ok((pos, _)) => {
                        let seq_res = {
                            parse_hexDigit(input, pos)
                        };
                        match seq_res {
                            Err(pos) => Err(pos),
                            Ok((pos, _)) => {
                                let match_str = input.slice(start_pos, pos);;
                                Ok((pos, { from_str_radix::<int>(match_str, 16) }))
                            }
                        }
                    }
                }
            };
            match seq_res {
                Err(pos) => Err(pos),
                Ok((pos, value)) => {
                    let match_str = input.slice(start_pos, pos);;
                    Ok((pos, {
      std::char::from_u32(value.unwrap() as u32).unwrap()
    }))
                }
            }
        }
    }
}
pub fn hexEscapeSequence(input: &str) -> Result<char, ~str> {
    match parse_hexEscapeSequence(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_unicodeEscapeSequence(input: &str, pos: uint) -> Result<(uint, char) , uint> {
    let start_pos = pos;
    let seq_res = {
        slice_eq(input, pos, "\\u")
    };
    match seq_res {
        Err(pos) => Err(pos),
        Ok((pos, _)) => {
            let seq_res = {
                let start_pos = pos;
                let seq_res = {
                    parse_hexDigit(input, pos)
                };
                match seq_res {
                    Err(pos) => Err(pos),
                    Ok((pos, _)) => {
                        let seq_res = {
                            parse_hexDigit(input, pos)
                        };
                        match seq_res {
                            Err(pos) => Err(pos),
                            Ok((pos, _)) => {
                                let seq_res = {
                                    parse_hexDigit(input, pos)
                                };
                                match seq_res {
                                    Err(pos) => Err(pos),
                                    Ok((pos, _)) => {
                                        let seq_res = {
                                            parse_hexDigit(input, pos)
                                        };
                                        match seq_res {
                                            Err(pos) => Err(pos),
                                            Ok((pos, _)) => {
                                                let match_str = input.slice(start_pos, pos);;
                                                Ok((pos, { from_str_radix::<int>(match_str, 16)}))
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            };
            match seq_res {
                Err(pos) => Err(pos),
                Ok((pos, value)) => {
                    let match_str = input.slice(start_pos, pos);;
                    Ok((pos, {
      std::char::from_u32(value.unwrap() as u32).unwrap()
    }))
                }
            }
        }
    }
}
pub fn unicodeEscapeSequence(input: &str) -> Result<char, ~str> {
    match parse_unicodeEscapeSequence(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_eolEscapeSequence(input: &str, pos: uint) -> Result<(uint, char) , uint> {
    let start_pos = pos;
    let seq_res = {
        slice_eq(input, pos, "\\")
    };
    match seq_res {
        Err(pos) => Err(pos),
        Ok((pos, _)) => {
            let seq_res = {
                parse_eol(input, pos)
            };
            match seq_res {
                Err(pos) => Err(pos),
                Ok((pos, eol)) => {
                    let match_str = input.slice(start_pos, pos);;
                    Ok((pos, { '\n' }))
                }
            }
        }
    }
}
pub fn eolEscapeSequence(input: &str) -> Result<char, ~str> {
    match parse_eolEscapeSequence(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_digit(input: &str, pos: uint) -> Result<(uint, ()) , uint> {
    if input.len() > pos {
        let CharRange {ch, next} = input.char_range_at(pos);
        match ch {
            '0'..'9' => { Ok((next, ())) }
            _ => Err(pos),
        }
    } else {
        Err(pos)
    }
}
pub fn digit(input: &str) -> Result<(), ~str> {
    match parse_digit(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_hexDigit(input: &str, pos: uint) -> Result<(uint, ()) , uint> {
    if input.len() > pos {
        let CharRange {ch, next} = input.char_range_at(pos);
        match ch {
            '0'..'9' | 'a'..'f' | 'A'..'F' => { Ok((next, ())) }
            _ => Err(pos),
        }
    } else {
        Err(pos)
    }
}
pub fn hexDigit(input: &str) -> Result<(), ~str> {
    match parse_hexDigit(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_letter(input: &str, pos: uint) -> Result<(uint, ()) , uint> {
    let choice_res = {
        parse_lowerCaseLetter(input, pos)
    };
    match choice_res {
        Ok((pos, value)) => Ok((pos, value)),
        Err(*) => {
            parse_upperCaseLetter(input, pos)
        }
    }
}
pub fn letter(input: &str) -> Result<(), ~str> {
    match parse_letter(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_lowerCaseLetter(input: &str, pos: uint) -> Result<(uint, ()) , uint> {
    if input.len() > pos {
        let CharRange {ch, next} = input.char_range_at(pos);
        match ch {
            'a'..'z' => { Ok((next, ())) }
            _ => Err(pos),
        }
    } else {
        Err(pos)
    }
}
pub fn lowerCaseLetter(input: &str) -> Result<(), ~str> {
    match parse_lowerCaseLetter(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_upperCaseLetter(input: &str, pos: uint) -> Result<(uint, ()) , uint> {
    if input.len() > pos {
        let CharRange {ch, next} = input.char_range_at(pos);
        match ch {
            'A'..'Z' => { Ok((next, ())) }
            _ => Err(pos),
        }
    } else {
        Err(pos)
    }
}
pub fn upperCaseLetter(input: &str) -> Result<(), ~str> {
    match parse_upperCaseLetter(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse___(input: &str, pos: uint) -> Result<(uint, ()) , uint> {
    let mut repeat_pos = pos;
    loop {
        let step_res = {
            let pos = repeat_pos;
            let choice_res = {
                parse_whitespace(input, pos)
            };
            match choice_res {
                Ok((pos, value)) => Ok((pos, value)),
                Err(*) => {
                    let choice_res = {
                        parse_eol(input, pos)
                    };
                    match choice_res {
                        Ok((pos, value)) => Ok((pos, value)),
                        Err(*) => {
                            parse_comment(input, pos)
                        }
                    }
                }
            }
        };
        match step_res {
            Ok((newpos, _)) => {
                repeat_pos = newpos;
            }
            Err(*) => {
                break;
            }
        }
    }
    Ok((repeat_pos, ()))
}
pub fn __(input: &str) -> Result<(), ~str> {
    match parse___(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_comment(input: &str, pos: uint) -> Result<(uint, ()) , uint> {
    let choice_res = {
        parse_singleLineComment(input, pos)
    };
    match choice_res {
        Ok((pos, value)) => Ok((pos, value)),
        Err(*) => {
            parse_multiLineComment(input, pos)
        }
    }
}
pub fn comment(input: &str) -> Result<(), ~str> {
    match parse_comment(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_singleLineComment(input: &str, pos: uint) -> Result<(uint, ()) , uint> {
    let seq_res = {
        slice_eq(input, pos, "//")
    };
    match seq_res {
        Err(pos) => Err(pos),
        Ok((pos, _)) => {
            let mut repeat_pos = pos;
            loop {
                let step_res = {
                    let pos = repeat_pos;
                    let seq_res = {
                        let neg_assert_res = {
                            parse_eolChar(input, pos)
                        };
                        match neg_assert_res {
                            Err(*) => Ok((pos, ())),
                            Ok(*) => Err(pos),
                        }
                    };
                    match seq_res {
                        Err(pos) => Err(pos),
                        Ok((pos, _)) => {
                            any_char(input, pos)
                        }
                    }
                };
                match step_res {
                    Ok((newpos, _)) => {
                        repeat_pos = newpos;
                    }
                    Err(*) => {
                        break;
                    }
                }
            }
            Ok((repeat_pos, ()))
        }
    }
}
pub fn singleLineComment(input: &str) -> Result<(), ~str> {
    match parse_singleLineComment(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_multiLineComment(input: &str, pos: uint) -> Result<(uint, ()) , uint> {
    let seq_res = {
        slice_eq(input, pos, "/*")
    };
    match seq_res {
        Err(pos) => Err(pos),
        Ok((pos, _)) => {
            let seq_res = {
                let mut repeat_pos = pos;
                loop {
                    let step_res = {
                        let pos = repeat_pos;
                        let seq_res = {
                            let neg_assert_res = {
                                slice_eq(input, pos, "*/")
                            };
                            match neg_assert_res {
                                Err(*) => Ok((pos, ())),
                                Ok(*) => Err(pos),
                            }
                        };
                        match seq_res {
                            Err(pos) => Err(pos),
                            Ok((pos, _)) => {
                                any_char(input, pos)
                            }
                        }
                    };
                    match step_res {
                        Ok((newpos, _)) => {
                            repeat_pos = newpos;
                        }
                        Err(*) => {
                            break;
                        }
                    }
                }
                Ok((repeat_pos, ()))
            };
            match seq_res {
                Err(pos) => Err(pos),
                Ok((pos, _)) => {
                    slice_eq(input, pos, "*/")
                }
            }
        }
    }
}
pub fn multiLineComment(input: &str) -> Result<(), ~str> {
    match parse_multiLineComment(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_eol(input: &str, pos: uint) -> Result<(uint, ()) , uint> {
    let choice_res = {
        slice_eq(input, pos, "\n")
    };
    match choice_res {
        Ok((pos, value)) => Ok((pos, value)),
        Err(*) => {
            let choice_res = {
                slice_eq(input, pos, "\r\n")
            };
            match choice_res {
                Ok((pos, value)) => Ok((pos, value)),
                Err(*) => {
                    let choice_res = {
                        slice_eq(input, pos, "\r")
                    };
                    match choice_res {
                        Ok((pos, value)) => Ok((pos, value)),
                        Err(*) => {
                            let choice_res = {
                                slice_eq(input, pos, "\u2028")
                            };
                            match choice_res {
                                Ok((pos, value)) => Ok((pos, value)),
                                Err(*) => {
                                    slice_eq(input, pos, "\u2029")
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
pub fn eol(input: &str) -> Result<(), ~str> {
    match parse_eol(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_eolChar(input: &str, pos: uint) -> Result<(uint, ()) , uint> {
    if input.len() > pos {
        let CharRange {ch, next} = input.char_range_at(pos);
        match ch {
            '\n' | '\r' | '\u2028' | '\u2029' => { Ok((next, ())) }
            _ => Err(pos),
        }
    } else {
        Err(pos)
    }
}
pub fn eolChar(input: &str) -> Result<(), ~str> {
    match parse_eolChar(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
#[allow(unused_variable)]
fn parse_whitespace(input: &str, pos: uint) -> Result<(uint, ()) , uint> {
    if input.len() > pos {
        let CharRange {ch, next} = input.char_range_at(pos);
        match ch {
            ' ' | '\t' | '\xa0' | '\ufeff' | '\u1680' | '\u180e' | '\u2000'..'\u200a' | '\u202f' | '\u205f' | '\u3000' => { Ok((next, ())) }
            _ => Err(pos),
        }
    } else {
        Err(pos)
    }
}
pub fn whitespace(input: &str) -> Result<(), ~str> {
    match parse_whitespace(input, 0) {
        Ok((pos, value)) => {
            if pos == input.len() {
                Ok(value)
            } else {
                Err(~"Unexpected characters at end of input")
            }
        }
        Err(pos) => Err("Error at "+ pos.to_str()),
    }
}
