// Generated by rust-peg. Do not edit.
use :: peg :: RuleResult :: { Matched , Failed } ; use translate ::*; use std :: char ; use codemap :: { self , Spanned } ; type Input = str ; type Position < 'input > = < Input as :: peg :: Parse < 'input >> :: Position ; type PositionRepr < 'input > = < Input as :: peg :: Parse < 'input >> :: PositionRepr ; struct ParseState < 'input > { _phantom : :: std :: marker :: PhantomData < & 'input ( ) > , primary_cache : :: std :: collections :: HashMap < usize , :: peg :: RuleResult < usize , Spanned < Expr > >> } impl < 'input > ParseState < 'input > { fn new ( ) -> ParseState < 'input > { ParseState { _phantom : :: std :: marker :: PhantomData , primary_cache : :: std :: collections :: HashMap :: new ( ) } } } fn __parse_items < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , Vec < Spanned < Item >> > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . is_empty ( ) { __pos } else { let __sep_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } ; let __step_res = { let __seq_res = Matched ( __pos , __pos ) ; match __seq_res { Matched ( __pos , start ) => { { let __seq_res = __parse_item ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , node ) => { { let __seq_res = Matched ( __pos , __pos ) ; match __seq_res { Matched ( __pos , end ) => { Matched ( __pos , { codemap :: Spanned { node , span : file_span . subspan ( start as u64 , end as u64 ) } } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , __repeat_value ) } ; match __seq_res { Matched ( __pos , items ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { items } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } fn __parse_peg_rule < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , Rule > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = __parse_cacheflag ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , cached ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_rust_visibility ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , visibility ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match { let __seq_res = __parse_RULE ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { __parse__ ( __input , __state , __err_state , __pos , file_span ) } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_identifier ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , name ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_returntype ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , ret_type ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "=" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "=" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_expression ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , expr ) => { { let __seq_res = match { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ";" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , ";" ) } } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { Rule { name , expr , ret_type , visibility , cached } } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } fn __parse_rust_visibility < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , Option < String > > { # ! [ allow ( non_snake_case , unused ) ] match { let __seq_res = { let str_start = __pos ; match { let __choice_res = { let __seq_res = __parse_PUB ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { match { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "(" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "(" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = { let __seq_res = { __err_state . suppress_fail += 1 ; let __assert_res = match :: peg :: ParseElem :: parse_elem ( __input , __pos ) { Matched ( __next , __ch ) => match __ch { ')' => Matched ( __next , ( ) ) , _ => __err_state . mark_failure ( __pos , "\')\'" ) , } Failed => __err_state . mark_failure ( __pos , "\')\'" ) } ; __err_state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } ; match __seq_res { Matched ( __pos , _ ) => { :: peg :: ParseElem :: parse_elem ( __input , __pos ) } Failed => Failed , } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , ( ) ) } else { Failed } } ; match __seq_res { Matched ( __pos , _ ) => { match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ")" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , ")" ) } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_CRATE ( __input , __state , __err_state , __pos , file_span ) } } { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , s ) => { Matched ( __pos , { s . to_owned ( ) } ) } Failed => Failed , } } { Matched ( __newpos , __value ) => { Matched ( __newpos , Some ( __value ) ) } , Failed => { Matched ( __pos , None ) } , } } fn __parse_cacheflag < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , bool > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "#[cache]" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "#[cache]" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { true } ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => Matched ( __pos , { false } ) } } } fn __parse_template < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , Template > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = __parse_identifier ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , name ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "<" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "<" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . is_empty ( ) { __pos } else { let __sep_res = { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "," ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "," ) } ; match __seq_res { Matched ( __pos , _ ) => { __parse__ ( __input , __state , __err_state , __pos , file_span ) } Failed => Failed , } } } Failed => Failed , } } ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } ; let __step_res = __parse_identifier ( __input , __state , __err_state , __pos , file_span ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , __repeat_value ) } ; match __seq_res { Matched ( __pos , list ) => { { let __seq_res = match { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "," ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "," ) } } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { list } ) } Failed => Failed , } } } Failed => Failed , } } ; match __seq_res { Matched ( __pos , params ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ">" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , ">" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "=" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "=" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_expression ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , expression ) => { { let __seq_res = match { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ";" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , ";" ) } } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { Template { name : name , params : params , expr : Box :: new ( expression ) } } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } fn __parse_item < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , Item > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { let __seq_res = __parse_rust_use ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , u ) => { Matched ( __pos , { Item :: Use ( u ) } ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = __parse_peg_rule ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , r ) => { Matched ( __pos , { Item :: Rule ( r ) } ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = __parse_template ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , t ) => { Matched ( __pos , { Item :: Template ( t ) } ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_grammar_args ( __input , __state , __err_state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_input_type ( __input , __state , __err_state , __pos , file_span ) } } } } } } } } } fn __parse_grammar_args < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , Item > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "#![" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "#![" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "arguments" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "arguments" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "(" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "(" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . is_empty ( ) { __pos } else { let __sep_res = { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "," ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "," ) } ; match __seq_res { Matched ( __pos , _ ) => { __parse__ ( __input , __state , __err_state , __pos , file_span ) } Failed => Failed , } } } Failed => Failed , } } ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } ; let __step_res = __parse_grammar_argument ( __input , __state , __err_state , __pos , file_span ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , __repeat_value ) } ; match __seq_res { Matched ( __pos , list ) => { { let __seq_res = match { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "," ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "," ) } } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { list } ) } Failed => Failed , } } } Failed => Failed , } } ; match __seq_res { Matched ( __pos , args ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ")" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , ")" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "]" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "]" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { Item :: GrammarArgs ( args ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } fn __parse_grammar_argument < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , ( String , String ) > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = __parse_identifier ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , i ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ":" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , ":" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_type_string ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , t ) => { Matched ( __pos , { ( i , t ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } fn __parse_input_type < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , Item > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "type" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "type" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "Input" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "Input" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "=" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "=" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_type_string ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , tp ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ";" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , ";" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { Item :: InputType ( tp ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } fn __parse_type_string < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , String > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { let str_start = __pos ; match __parse_rust_type ( __input , __state , __err_state , __pos , file_span ) { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , tp ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { tp . to_owned ( ) } ) } Failed => Failed , } } } Failed => Failed , } } } fn __parse_returntype < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , String > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "->" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "->" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_type_string ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , tp ) => { Matched ( __pos , { tp } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => Matched ( __pos , { "()" . to_string ( ) } ) } } } fn __parse_rust_identifier < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , ( ) > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { __err_state . suppress_fail += 1 ; let res = { let __seq_res = __parse_idStart ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let mut __repeat_pos = __pos ; loop { let __pos = __repeat_pos ; let __step_res = __parse_idContinue ( __input , __state , __err_state , __pos , file_span ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; } , Failed => { break ; } } } Matched ( __repeat_pos , ( ) ) } } Failed => Failed , } } ; __err_state . suppress_fail -= 1 ; res } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { __err_state . mark_failure ( __pos , "identifier" ) ; Failed } } } } fn __parse_rust_use < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , String > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { let str_start = __pos ; match { let __seq_res = __parse_USE ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_rust_path ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "::" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "::" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "*" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "*" ) } ; match __seq_res { Matched ( __pos , _ ) => { __parse__ ( __input , __state , __err_state , __pos , file_span ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "::" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "::" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "{" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "{" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . is_empty ( ) { __pos } else { let __sep_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "," ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "," ) } ; match __seq_res { Matched ( __pos , _ ) => { __parse__ ( __input , __state , __err_state , __pos , file_span ) } Failed => Failed , } } ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } ; let __step_res = { let __seq_res = __parse_rust_identifier ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { match { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "as" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "as" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_rust_identifier ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { __parse__ ( __input , __state , __err_state , __pos , file_span ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } } Failed => Failed , } } } Failed => Failed , } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , ( ) ) } else { Failed } } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "}" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "}" ) } ; match __seq_res { Matched ( __pos , _ ) => { __parse__ ( __input , __state , __err_state , __pos , file_span ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => match { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "as" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "as" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { __parse_rust_identifier ( __input , __state , __err_state , __pos , file_span ) } Failed => Failed , } } } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } } } } } ; match __seq_res { Matched ( __pos , _ ) => { match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ";" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , ";" ) } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , v ) => { Matched ( __pos , { v . to_owned ( ) } ) } Failed => Failed , } } } fn __parse_rust_path < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , ( ) > { # ! [ allow ( non_snake_case , unused ) ] { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . is_empty ( ) { __pos } else { let __sep_res = { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "::" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "::" ) } ; match __seq_res { Matched ( __pos , _ ) => { __parse__ ( __input , __state , __err_state , __pos , file_span ) } Failed => Failed , } } } Failed => Failed , } } ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } ; let __step_res = __parse_rust_identifier ( __input , __state , __err_state , __pos , file_span ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , ( ) ) } else { Failed } } } fn __parse_rust_type < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , ( ) > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "[" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "[" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_rust_type ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "]" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "]" ) } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "&" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "&" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "mut" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "mut" ) } ; match __seq_res { Matched ( __pos , _ ) => { __parse__ ( __input , __state , __err_state , __pos , file_span ) } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "\'" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\'" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_rust_identifier ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { __parse__ ( __input , __state , __err_state , __pos , file_span ) } Failed => Failed , } } } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } ; match __seq_res { Matched ( __pos , _ ) => { __parse_rust_type ( __input , __state , __err_state , __pos , file_span ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "dyn" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "dyn" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { __parse_rust_type ( __input , __state , __err_state , __pos , file_span ) } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "impl" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "impl" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { __parse_rust_type ( __input , __state , __err_state , __pos , file_span ) } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = __parse_rust_identifier ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "<" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "<" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . is_empty ( ) { __pos } else { let __sep_res = { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "," ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "," ) } ; match __seq_res { Matched ( __pos , _ ) => { __parse__ ( __input , __state , __err_state , __pos , file_span ) } Failed => Failed , } } } Failed => Failed , } } ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } ; let __step_res = { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "\'" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\'" ) } ; match __seq_res { Matched ( __pos , _ ) => { __parse_rust_identifier ( __input , __state , __err_state , __pos , file_span ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_rust_type ( __input , __state , __err_state , __pos , file_span ) } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , ( ) ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ">" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , ">" ) } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = __parse_rust_identifier ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "::" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "::" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { __parse_rust_type ( __input , __state , __err_state , __pos , file_span ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "(" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "(" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . is_empty ( ) { __pos } else { let __sep_res = { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "," ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "," ) } ; match __seq_res { Matched ( __pos , _ ) => { __parse__ ( __input , __state , __err_state , __pos , file_span ) } Failed => Failed , } } } Failed => Failed , } } ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } ; let __step_res = __parse_rust_type ( __input , __state , __err_state , __pos , file_span ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , ( ) ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ")" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , ")" ) } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_rust_identifier ( __input , __state , __err_state , __pos , file_span ) } } } } } } } } } } } } } } } fn __parse_expression < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , Spanned < Expr > > { # ! [ allow ( non_snake_case , unused ) ] __parse_choice ( __input , __state , __err_state , __pos , file_span ) } fn __parse_choice < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , Spanned < Expr > > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = Matched ( __pos , __pos ) ; match __seq_res { Matched ( __pos , start ) => { { let __seq_res = { let __seq_res = __parse_sequence ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , head ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "/" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "/" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_sequence ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , s ) => { Matched ( __pos , { s } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , __repeat_value ) } ; match __seq_res { Matched ( __pos , tail ) => { Matched ( __pos , { if tail . is_empty ( ) { head . node } else { let mut list = tail ; list . insert ( 0 , head ) ; ChoiceExpr ( list ) } } ) } Failed => Failed , } } } Failed => Failed , } } ; match __seq_res { Matched ( __pos , node ) => { { let __seq_res = Matched ( __pos , __pos ) ; match __seq_res { Matched ( __pos , end ) => { Matched ( __pos , { codemap :: Spanned { node , span : file_span . subspan ( start as u64 , end as u64 ) } } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } fn __parse_sequence < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , Spanned < Expr > > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = Matched ( __pos , __pos ) ; match __seq_res { Matched ( __pos , start ) => { { let __seq_res = { let __choice_res = { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . is_empty ( ) { __pos } else { let __sep_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } ; let __step_res = __parse_labeled ( __input , __state , __err_state , __pos , file_span ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , __repeat_value ) } ; match __seq_res { Matched ( __pos , elements ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_action ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , code ) => { Matched ( __pos , { ActionExpr ( elements , code . 0 , code . 1 ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . is_empty ( ) { __pos } else { let __sep_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } ; let __step_res = __parse_prefixed ( __input , __state , __err_state , __pos , file_span ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , __repeat_value ) } ; match __seq_res { Matched ( __pos , elements ) => { Matched ( __pos , { if elements . len ( ) != 1 { SequenceExpr ( elements ) } else { elements . into_iter ( ) . next ( ) . unwrap ( ) . node } } ) } Failed => Failed , } } } } ; match __seq_res { Matched ( __pos , node ) => { { let __seq_res = Matched ( __pos , __pos ) ; match __seq_res { Matched ( __pos , end ) => { Matched ( __pos , { codemap :: Spanned { node , span : file_span . subspan ( start as u64 , end as u64 ) } } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } fn __parse_labeled < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , TaggedExpr > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = match { let __seq_res = { let __seq_res = Matched ( __pos , __pos ) ; match __seq_res { Matched ( __pos , start ) => { { let __seq_res = __parse_identifier ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , node ) => { { let __seq_res = Matched ( __pos , __pos ) ; match __seq_res { Matched ( __pos , end ) => { Matched ( __pos , { codemap :: Spanned { node , span : file_span . subspan ( start as u64 , end as u64 ) } } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __seq_res { Matched ( __pos , l ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ":" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , ":" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { l } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } { Matched ( __newpos , __value ) => { Matched ( __newpos , Some ( __value ) ) } , Failed => { Matched ( __pos , None ) } , } ; match __seq_res { Matched ( __pos , label ) => { { let __seq_res = __parse_prefixed ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , expression ) => { Matched ( __pos , { TaggedExpr { name : label , expr : Box :: new ( expression ) } } ) } Failed => Failed , } } } Failed => Failed , } } } fn __parse_prefixed < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , Spanned < Expr > > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { let __seq_res = Matched ( __pos , __pos ) ; match __seq_res { Matched ( __pos , start ) => { { let __seq_res = { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "$" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "$" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_suffixed ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , expression ) => { Matched ( __pos , { MatchStrExpr ( Box :: new ( expression ) ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "&" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "&" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_suffixed ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , expression ) => { Matched ( __pos , { PosAssertExpr ( Box :: new ( expression ) ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "!" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "!" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_suffixed ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , expression ) => { Matched ( __pos , { NegAssertExpr ( Box :: new ( expression ) ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } } } } ; match __seq_res { Matched ( __pos , node ) => { { let __seq_res = Matched ( __pos , __pos ) ; match __seq_res { Matched ( __pos , end ) => { Matched ( __pos , { codemap :: Spanned { node , span : file_span . subspan ( start as u64 , end as u64 ) } } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_suffixed ( __input , __state , __err_state , __pos , file_span ) } } } fn __parse_suffixed < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , Spanned < Expr > > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { let __seq_res = Matched ( __pos , __pos ) ; match __seq_res { Matched ( __pos , start ) => { { let __seq_res = { let __choice_res = { let __seq_res = __parse_primary ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , e ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "?" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "?" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { OptionalExpr ( Box :: new ( e ) ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = __parse_primary ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , e ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "**" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "**" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_repeatcount ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , count ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_primary ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , sep ) => { Matched ( __pos , { Repeat ( Box :: new ( e ) , count , Some ( Box :: new ( sep ) ) ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = __parse_primary ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , e ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "++" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "++" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_primary ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , sep ) => { Matched ( __pos , { Repeat ( Box :: new ( e ) , BoundedRepeat :: Plus , Some ( Box :: new ( sep ) ) ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = __parse_primary ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , e ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "*" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "*" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_repeatcount ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , count ) => { Matched ( __pos , { Repeat ( Box :: new ( e ) , count , None ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __seq_res = __parse_primary ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , e ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "+" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "+" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { Repeat ( Box :: new ( e ) , BoundedRepeat :: Plus , None ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } } } } } } } } ; match __seq_res { Matched ( __pos , node ) => { { let __seq_res = Matched ( __pos , __pos ) ; match __seq_res { Matched ( __pos , end ) => { Matched ( __pos , { codemap :: Spanned { node , span : file_span . subspan ( start as u64 , end as u64 ) } } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_primary ( __input , __state , __err_state , __pos , file_span ) } } } fn __parse_repeatcount < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , BoundedRepeat > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "<" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "<" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_repeatnum ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , n ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ">" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , ">" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { BoundedRepeat :: Exact ( n ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "<" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "<" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match __parse_repeatnum ( __input , __state , __err_state , __pos , file_span ) { Matched ( __newpos , __value ) => { Matched ( __newpos , Some ( __value ) ) } , Failed => { Matched ( __pos , None ) } , } ; match __seq_res { Matched ( __pos , min ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "," ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "," ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match __parse_repeatnum ( __input , __state , __err_state , __pos , file_span ) { Matched ( __newpos , __value ) => { Matched ( __newpos , Some ( __value ) ) } , Failed => { Matched ( __pos , None ) } , } ; match __seq_res { Matched ( __pos , max ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ">" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , ">" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { BoundedRepeat :: Both ( min , max ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => Matched ( __pos , { BoundedRepeat :: None } ) } } } } } fn __parse_repeatnum < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , String > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { let __seq_res = __parse_integer ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , i ) => { Matched ( __pos , { i . to_string ( ) } ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "{" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "{" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_rust_expr ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , e ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "}" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "}" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { e } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } } } fn __parse_primary < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , Spanned < Expr > > { # ! [ allow ( non_snake_case , unused ) ] if let Some ( entry ) = __state . primary_cache . get ( & __pos ) { return entry . clone ( ) ; } let __rule_result = { let __seq_res = Matched ( __pos , __pos ) ; match __seq_res { Matched ( __pos , start ) => { { let __seq_res = { let __choice_res = { let __seq_res = __parse_identifier ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , name ) => { { let __seq_res = { __err_state . suppress_fail += 1 ; let __assert_res = { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __choice_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "<" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "<" ) } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "->" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "->" ) } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "=" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "=" ) } } } } } } Failed => Failed , } } ; __err_state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { RuleExpr ( name ) } ) } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = __parse_identifier ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , name ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "<" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "<" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . is_empty ( ) { __pos } else { let __sep_res = { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "," ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "," ) } ; match __seq_res { Matched ( __pos , _ ) => { __parse__ ( __input , __state , __err_state , __pos , file_span ) } Failed => Failed , } } } Failed => Failed , } } ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } ; let __step_res = __parse_expression ( __input , __state , __err_state , __pos , file_span ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , __repeat_value ) } ; match __seq_res { Matched ( __pos , list ) => { { let __seq_res = match { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "," ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "," ) } } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { list } ) } Failed => Failed , } } } Failed => Failed , } } ; match __seq_res { Matched ( __pos , args ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ">" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , ">" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { __err_state . suppress_fail += 1 ; let __assert_res = { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "=" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "=" ) } } Failed => Failed , } } ; __err_state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { TemplateInvoke ( name , args ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_literal ( __input , __state , __err_state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_class ( __input , __state , __err_state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "." ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "." ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { AnyCharExpr } ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "@" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "@" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { MarkerExpr } ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "#position" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "#position" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { PositionExpr } ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "#quiet" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "#quiet" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "<" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "<" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_expression ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , e ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ">" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , ">" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { QuietExpr ( Box :: new ( e ) ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "#expected" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "#expected" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "(" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "(" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_doubleQuotedString ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , s ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ")" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , ")" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { FailExpr ( s ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "#infix" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "#infix" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "<" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "<" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_expression ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , atom ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ">" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , ">" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "{" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "{" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . is_empty ( ) { __pos } else { let __sep_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } ; let __step_res = __parse_infix_level ( __input , __state , __err_state , __pos , file_span ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , __repeat_value ) } else { Failed } } ; match __seq_res { Matched ( __pos , levels ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "}" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "}" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { InfixExpr { atom : Box :: new ( atom ) , levels : levels } } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "(" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "(" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_expression ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , expression ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ")" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , ")" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { expression . node } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } } } } } } } } } } } } } } } } } } } } ; match __seq_res { Matched ( __pos , node ) => { { let __seq_res = Matched ( __pos , __pos ) ; match __seq_res { Matched ( __pos , end ) => { Matched ( __pos , { codemap :: Spanned { node , span : file_span . subspan ( start as u64 , end as u64 ) } } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; __state . primary_cache . insert ( __pos , __rule_result . clone ( ) ) ; __rule_result } fn __parse_infix_level < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , InfixLevel > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "#L" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "#L" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { InfixAssoc :: Left } ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "#R" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "#R" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { InfixAssoc :: Right } ) } Failed => Failed , } } } } ; match __seq_res { Matched ( __pos , assoc ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . is_empty ( ) { __pos } else { let __sep_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } ; let __step_res = { let __seq_res = Matched ( __pos , __pos ) ; match __seq_res { Matched ( __pos , start ) => { { let __seq_res = __parse_infix_op ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , node ) => { { let __seq_res = Matched ( __pos , __pos ) ; match __seq_res { Matched ( __pos , end ) => { Matched ( __pos , { codemap :: Spanned { node , span : file_span . subspan ( start as u64 , end as u64 ) } } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , __repeat_value ) } else { Failed } } ; match __seq_res { Matched ( __pos , operators ) => { Matched ( __pos , { InfixLevel { assoc : assoc , operators : operators } } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } fn __parse_infix_op < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , InfixOperator > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . is_empty ( ) { __pos } else { let __sep_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } ; let __step_res = __parse_labeled ( __input , __state , __err_state , __pos , file_span ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , __repeat_value ) } ; match __seq_res { Matched ( __pos , elements ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "{" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "{" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_rust_expr ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , action ) => { { let __seq_res = __parse__ ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "}" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "}" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { InfixOperator { elements , action } } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } fn __parse_rust_expr < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , String > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { let str_start = __pos ; match { let mut __repeat_pos = __pos ; loop { let __pos = __repeat_pos ; let __step_res = { let __choice_res = __parse_braced ( __input , __state , __err_state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_nonBraceCharacters ( __input , __state , __err_state , __pos , file_span ) } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; } , Failed => { break ; } } } Matched ( __repeat_pos , ( ) ) } { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , literal ) => { Matched ( __pos , { format ! ( "{{ {} }}" , literal ) } ) } Failed => Failed , } } } fn __parse_action < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , ( String , bool ) > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "{" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "{" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "?" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "?" ) } { Matched ( __newpos , __value ) => { Matched ( __newpos , Some ( __value ) ) } , Failed => { Matched ( __pos , None ) } , } ; match __seq_res { Matched ( __pos , cond ) => { { let __seq_res = __parse_rust_expr ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , literal ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "}" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "}" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { ( literal , cond . is_some ( ) ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } fn __parse_braced < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , ( ) > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "{" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "{" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; loop { let __pos = __repeat_pos ; let __step_res = { let __choice_res = __parse_braced ( __input , __state , __err_state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_nonBraceCharacters ( __input , __state , __err_state , __pos , file_span ) } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; } , Failed => { break ; } } } Matched ( __repeat_pos , ( ) ) } ; match __seq_res { Matched ( __pos , _ ) => { match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "}" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "}" ) } } Failed => Failed , } } } Failed => Failed , } } } fn __parse_nonBraceCharacters < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , ( ) > { # ! [ allow ( non_snake_case , unused ) ] { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = { let __seq_res = { __err_state . suppress_fail += 1 ; let __assert_res = match :: peg :: ParseElem :: parse_elem ( __input , __pos ) { Matched ( __next , __ch ) => match __ch { '{' | '}' => Matched ( __next , ( ) ) , _ => __err_state . mark_failure ( __pos , "\'{\' | \'}\' " ) , } Failed => __err_state . mark_failure ( __pos , "\'{\' | \'}\' " ) } ; __err_state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } ; match __seq_res { Matched ( __pos , _ ) => { :: peg :: ParseElem :: parse_elem ( __input , __pos ) } Failed => Failed , } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , ( ) ) } else { Failed } } } fn __parse_USE < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , ( ) > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "use" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "use" ) } ; match __seq_res { Matched ( __pos , _ ) => { { __err_state . suppress_fail += 1 ; let __assert_res = __parse_idContinue ( __input , __state , __err_state , __pos , file_span ) ; __err_state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } } Failed => Failed , } } } fn __parse_PUB < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , ( ) > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "pub" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "pub" ) } ; match __seq_res { Matched ( __pos , _ ) => { { __err_state . suppress_fail += 1 ; let __assert_res = __parse_idContinue ( __input , __state , __err_state , __pos , file_span ) ; __err_state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } } Failed => Failed , } } } fn __parse_CRATE < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , ( ) > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "crate" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "crate" ) } ; match __seq_res { Matched ( __pos , _ ) => { { __err_state . suppress_fail += 1 ; let __assert_res = __parse_idContinue ( __input , __state , __err_state , __pos , file_span ) ; __err_state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } } Failed => Failed , } } } fn __parse_RULE < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , ( ) > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "rule" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "rule" ) } ; match __seq_res { Matched ( __pos , _ ) => { { __err_state . suppress_fail += 1 ; let __assert_res = __parse_idContinue ( __input , __state , __err_state , __pos , file_span ) ; __err_state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } } Failed => Failed , } } } fn __parse_keyword < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , ( ) > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = __parse_USE ( __input , __state , __err_state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_PUB ( __input , __state , __err_state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_CRATE ( __input , __state , __err_state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_RULE ( __input , __state , __err_state , __pos , file_span ) } } } } } } } fn __parse_integer < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , usize > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { let str_start = __pos ; match { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = match :: peg :: ParseElem :: parse_elem ( __input , __pos ) { Matched ( __next , __ch ) => match __ch { '0' ..='9' => Matched ( __next , ( ) ) , _ => __err_state . mark_failure ( __pos , "\'0\'..=\'9\'" ) , } Failed => __err_state . mark_failure ( __pos , "\'0\'..=\'9\'" ) } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , ( ) ) } else { Failed } } { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , i ) => { Matched ( __pos , { i . parse ( ) . unwrap ( ) } ) } Failed => Failed , } } } fn __parse_idStart < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , ( ) > { # ! [ allow ( non_snake_case , unused ) ] match :: peg :: ParseElem :: parse_elem ( __input , __pos ) { Matched ( __next , __ch ) => match __ch { 'a' ..='z' | 'A' ..='Z' | '_' => Matched ( __next , ( ) ) , _ => __err_state . mark_failure ( __pos , "\'a\'..=\'z\' | \'A\'..=\'Z\' | \'_\'" ) , } Failed => __err_state . mark_failure ( __pos , "\'a\'..=\'z\' | \'A\'..=\'Z\' | \'_\'" ) } } fn __parse_idContinue < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , ( ) > { # ! [ allow ( non_snake_case , unused ) ] match :: peg :: ParseElem :: parse_elem ( __input , __pos ) { Matched ( __next , __ch ) => match __ch { 'a' ..='z' | 'A' ..='Z' | '0' ..='9' | '_' => Matched ( __next , ( ) ) , _ => __err_state . mark_failure ( __pos , "\'a\'..=\'z\' | \'A\'..=\'Z\' | \'0\'..=\'9\' | \'_\'" ) , } Failed => __err_state . mark_failure ( __pos , "\'a\'..=\'z\' | \'A\'..=\'Z\' | \'0\'..=\'9\' | \'_\'" ) } } fn __parse_identifier < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , String > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { __err_state . suppress_fail += 1 ; let res = { let __seq_res = { __err_state . suppress_fail += 1 ; let __assert_res = __parse_keyword ( __input , __state , __err_state , __pos , file_span ) ; __err_state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let str_start = __pos ; match { let __seq_res = __parse_idStart ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { { let mut __repeat_pos = __pos ; loop { let __pos = __repeat_pos ; let __step_res = __parse_idContinue ( __input , __state , __err_state , __pos , file_span ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; } , Failed => { break ; } } } Matched ( __repeat_pos , ( ) ) } } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , chars ) => { Matched ( __pos , { chars . to_owned ( ) } ) } Failed => Failed , } } } Failed => Failed , } } ; __err_state . suppress_fail -= 1 ; res } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { __err_state . mark_failure ( __pos , "identifier" ) ; Failed } } } } fn __parse_literal < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , Expr > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { let __choice_res = __parse_doubleQuotedString ( __input , __state , __err_state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_singleQuotedString ( __input , __state , __err_state , __pos , file_span ) } } ; match __seq_res { Matched ( __pos , value ) => { Matched ( __pos , { LiteralExpr ( value ) } ) } Failed => Failed , } } } fn __parse_string < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , String > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { let __choice_res = __parse_doubleQuotedString ( __input , __state , __err_state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_singleQuotedString ( __input , __state , __err_state , __pos , file_span ) } } ; match __seq_res { Matched ( __pos , string ) => { Matched ( __pos , { string } ) } Failed => Failed , } } } fn __parse_doubleQuotedString < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , String > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "\"" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = __parse_doubleQuotedCharacter ( __input , __state , __err_state , __pos , file_span ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , __repeat_value ) } ; match __seq_res { Matched ( __pos , s ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "\"" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { s . into_iter ( ) . collect ( ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } fn __parse_doubleQuotedCharacter < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , char > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = __parse_simpleDoubleQuotedCharacter ( __input , __state , __err_state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_simpleEscapeSequence ( __input , __state , __err_state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_zeroEscapeSequence ( __input , __state , __err_state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_hex2EscapeSequence ( __input , __state , __err_state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_unicodeEscapeSequence ( __input , __state , __err_state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_eolEscapeSequence ( __input , __state , __err_state , __pos , file_span ) } } } } } } } } } } } fn __parse_simpleDoubleQuotedCharacter < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , char > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { __err_state . suppress_fail += 1 ; let __assert_res = { let __choice_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "\"" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"" ) } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "\\" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\\" ) } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_eolChar ( __input , __state , __err_state , __pos , file_span ) } } } } ; __err_state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let str_start = __pos ; match :: peg :: ParseElem :: parse_elem ( __input , __pos ) { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , c ) => { Matched ( __pos , { c . chars ( ) . next ( ) . unwrap ( ) } ) } Failed => Failed , } } } Failed => Failed , } } } fn __parse_singleQuotedString < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , String > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "\'" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\'" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = __parse_singleQuotedCharacter ( __input , __state , __err_state , __pos , file_span ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , __repeat_value ) } ; match __seq_res { Matched ( __pos , s ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "\'" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\'" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { s . into_iter ( ) . collect ( ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } fn __parse_singleQuotedCharacter < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , char > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = __parse_simpleSingleQuotedCharacter ( __input , __state , __err_state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_simpleEscapeSequence ( __input , __state , __err_state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_zeroEscapeSequence ( __input , __state , __err_state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_hex2EscapeSequence ( __input , __state , __err_state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_unicodeEscapeSequence ( __input , __state , __err_state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_eolEscapeSequence ( __input , __state , __err_state , __pos , file_span ) } } } } } } } } } } } fn __parse_simpleSingleQuotedCharacter < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , char > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { __err_state . suppress_fail += 1 ; let __assert_res = { let __choice_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "\'" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\'" ) } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "\\" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\\" ) } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_eolChar ( __input , __state , __err_state , __pos , file_span ) } } } } ; __err_state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let str_start = __pos ; match :: peg :: ParseElem :: parse_elem ( __input , __pos ) { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , c ) => { Matched ( __pos , { c . chars ( ) . next ( ) . unwrap ( ) } ) } Failed => Failed , } } } Failed => Failed , } } } fn __parse_class < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , Expr > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "[" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "[" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let str_start = __pos ; match { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = { let __seq_res = { __err_state . suppress_fail += 1 ; let __assert_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "]" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "]" ) } ; __err_state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } ; match __seq_res { Matched ( __pos , _ ) => { :: peg :: ParseElem :: parse_elem ( __input , __pos ) } Failed => Failed , } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , ( ) ) } else { Failed } } { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , pattern ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "]" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "]" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { PatternExpr ( pattern . to_owned ( ) ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } fn __parse_simpleEscapeSequence < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , char > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "\\" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\\" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { __err_state . suppress_fail += 1 ; let __assert_res = { let __choice_res = __parse_digit ( __input , __state , __err_state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "x" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "x" ) } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "u" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "u" ) } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_eolChar ( __input , __state , __err_state , __pos , file_span ) } } } } } } ; __err_state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let str_start = __pos ; match :: peg :: ParseElem :: parse_elem ( __input , __pos ) { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , c ) => { Matched ( __pos , { match c . chars ( ) . next ( ) . unwrap ( ) { 'n' => '\n' , 'r' => '\r' , 't' => '\t' , x => x } } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } fn __parse_zeroEscapeSequence < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , char > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "\\0" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\\0" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { __err_state . suppress_fail += 1 ; let __assert_res = __parse_digit ( __input , __state , __err_state , __pos , file_span ) ; __err_state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { 0u8 as char } ) } Failed => Failed , } } } Failed => Failed , } } } fn __parse_hex2EscapeSequence < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , char > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "\\x" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\\x" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let str_start = __pos ; match { let __seq_res = __parse_hexDigit ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { __parse_hexDigit ( __input , __state , __err_state , __pos , file_span ) } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , value ) => { Matched ( __pos , { char :: from_u32 ( u32 :: from_str_radix ( value , 16 ) . unwrap ( ) ) . unwrap ( ) } ) } Failed => Failed , } } } Failed => Failed , } } } fn __parse_unicodeEscapeSequence < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , char > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "\\u{" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\\u{" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let str_start = __pos ; match { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = __parse_hexDigit ( __input , __state , __err_state , __pos , file_span ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , ( ) ) } else { Failed } } { Matched ( __newpos , _ ) => { Matched ( __newpos , & __input [ str_start .. __newpos ] ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , value ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "}" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "}" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { char :: from_u32 ( u32 :: from_str_radix ( value , 16 ) . unwrap ( ) ) . unwrap ( ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } fn __parse_eolEscapeSequence < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , char > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "\\" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\\" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_eol ( __input , __state , __err_state , __pos , file_span ) ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { '\n' } ) } Failed => Failed , } } } Failed => Failed , } } } fn __parse_digit < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , ( ) > { # ! [ allow ( non_snake_case , unused ) ] match :: peg :: ParseElem :: parse_elem ( __input , __pos ) { Matched ( __next , __ch ) => match __ch { '0' ..='9' => Matched ( __next , ( ) ) , _ => __err_state . mark_failure ( __pos , "\'0\'..=\'9\'" ) , } Failed => __err_state . mark_failure ( __pos , "\'0\'..=\'9\'" ) } } fn __parse_hexDigit < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , ( ) > { # ! [ allow ( non_snake_case , unused ) ] match :: peg :: ParseElem :: parse_elem ( __input , __pos ) { Matched ( __next , __ch ) => match __ch { '0' ..='9' | 'a' ..='f' | 'A' ..='F' => Matched ( __next , ( ) ) , _ => __err_state . mark_failure ( __pos , " \'0\'..=\'9\' | \'a\'..=\'f\' | \'A\'..=\'F\' " ) , } Failed => __err_state . mark_failure ( __pos , " \'0\'..=\'9\' | \'a\'..=\'f\' | \'A\'..=\'F\' " ) } } fn __parse__ < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , ( ) > { # ! [ allow ( non_snake_case , unused ) ] { __err_state . suppress_fail += 1 ; let res = { let mut __repeat_pos = __pos ; loop { let __pos = __repeat_pos ; let __step_res = { let __choice_res = __parse_whitespace ( __input , __state , __err_state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_eol ( __input , __state , __err_state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_comment ( __input , __state , __err_state , __pos , file_span ) } } } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; } , Failed => { break ; } } } Matched ( __repeat_pos , ( ) ) } ; __err_state . suppress_fail -= 1 ; res } } fn __parse_comment < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , ( ) > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = __parse_singleLineComment ( __input , __state , __err_state , __pos , file_span ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_multiLineComment ( __input , __state , __err_state , __pos , file_span ) } } } fn __parse_singleLineComment < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , ( ) > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "//" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "//" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let mut __repeat_pos = __pos ; loop { let __pos = __repeat_pos ; let __step_res = { let __seq_res = { __err_state . suppress_fail += 1 ; let __assert_res = __parse_eolChar ( __input , __state , __err_state , __pos , file_span ) ; __err_state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } ; match __seq_res { Matched ( __pos , _ ) => { :: peg :: ParseElem :: parse_elem ( __input , __pos ) } Failed => Failed , } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; } , Failed => { break ; } } } Matched ( __repeat_pos , ( ) ) } } Failed => Failed , } } } fn __parse_multiLineComment < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , ( ) > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "/*" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "/*" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; loop { let __pos = __repeat_pos ; let __step_res = { let __seq_res = { __err_state . suppress_fail += 1 ; let __assert_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "*/" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "*/" ) } ; __err_state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } ; match __seq_res { Matched ( __pos , _ ) => { :: peg :: ParseElem :: parse_elem ( __input , __pos ) } Failed => Failed , } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; } , Failed => { break ; } } } Matched ( __repeat_pos , ( ) ) } ; match __seq_res { Matched ( __pos , _ ) => { match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "*/" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "*/" ) } } Failed => Failed , } } } Failed => Failed , } } } fn __parse_eol < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , ( ) > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "\n" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\n" ) } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "\r\n" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\r\n" ) } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "\r" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\r" ) } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "\u{2028}" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\u{2028}" ) } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "\u{2029}" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\u{2029}" ) } } } } } } } } } } fn __parse_eolChar < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , ( ) > { # ! [ allow ( non_snake_case , unused ) ] match :: peg :: ParseElem :: parse_elem ( __input , __pos ) { Matched ( __next , __ch ) => match __ch { '\n' | '\r' | '\u{2028}' | '\u{2029}' => Matched ( __next , ( ) ) , _ => __err_state . mark_failure ( __pos , "\'\\n\' | \'\\r\' | \'\\u{2028}\' | \'\\u{2029}\'" ) , } Failed => __err_state . mark_failure ( __pos , "\'\\n\' | \'\\r\' | \'\\u{2028}\' | \'\\u{2029}\'" ) } } fn __parse_whitespace < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > , file_span : codemap :: Span ) -> :: peg :: RuleResult < usize , ( ) > { # ! [ allow ( non_snake_case , unused ) ] match :: peg :: ParseElem :: parse_elem ( __input , __pos ) { Matched ( __next , __ch ) => match __ch { ' ' | '\t' => Matched ( __next , ( ) ) , _ => __err_state . mark_failure ( __pos , "\' \' | \'\\t\'" ) , } Failed => __err_state . mark_failure ( __pos , "\' \' | \'\\t\'" ) } } pub fn items < 'input > ( __input : & 'input Input , file_span : codemap :: Span ) -> Result < Vec < Spanned < Item >> , :: peg :: error :: ParseError < PositionRepr < 'input >> > { # ! [ allow ( non_snake_case , unused ) ] let mut __err_state = :: peg :: error :: ErrorState :: new ( :: peg :: Parse :: start ( __input ) ) ; let mut __state = ParseState :: new ( ) ; match __parse_items ( __input , & mut __state , & mut __err_state , :: peg :: Parse :: start ( __input ) , file_span ) { Matched ( __pos , __value ) => { if __pos == __input . len ( ) { return Ok ( __value ) } } _ => ( ) } __state = ParseState :: new ( ) ; __err_state . reparse_for_error ( ) ; __parse_items ( __input , & mut __state , & mut __err_state , :: peg :: Parse :: start ( __input ) , file_span ) ; let loc = :: peg :: Parse :: position_repr ( __input , __err_state . max_err_pos ) ; ; Err ( :: peg :: error :: ParseError { location : loc , expected : __err_state . expected , } ) }