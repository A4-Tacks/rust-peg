// Generated by rust-peg. Do not edit.
pub mod peg { use :: peg :: RuleResult :: { Matched , Failed } ; type Input = FlatTokenStream ; type Position < 'input > = < Input as :: peg :: Parse < 'input >> :: Position ; type PositionRepr < 'input > = < Input as :: peg :: Parse < 'input >> :: PositionRepr ; struct ParseState < 'input > { _phantom : :: std :: marker :: PhantomData < & 'input ( ) > , primary_cache : :: std :: collections :: HashMap < usize , :: peg :: RuleResult < usize , Expr >> } impl < 'input > ParseState < 'input > { fn new ( ) -> ParseState < 'input > { ParseState { _phantom : :: std :: marker :: PhantomData , primary_cache : :: std :: collections :: HashMap :: new ( ) } } } use ast ::*; use self :: Expr ::*; use tokens :: FlatTokenStream ; use proc_macro2 :: { TokenStream , Ident , Literal , Delimiter } ; pub fn peg_grammar < 'input > ( __input : & 'input Input ) -> Result < Grammar , :: peg :: error :: ParseError < PositionRepr < 'input >> > { # ! [ allow ( non_snake_case , unused ) ] let mut __err_state = :: peg :: error :: ErrorState :: new ( :: peg :: Parse :: start ( __input ) ) ; let mut __state = ParseState :: new ( ) ; match __parse_peg_grammar ( __input , & mut __state , & mut __err_state , :: peg :: Parse :: start ( __input ) ) { Matched ( __pos , __value ) => { if __pos == __input . len ( ) { return Ok ( __value ) } else { __err_state . mark_failure ( __pos , "EOF" ) ; } } _ => ( ) } __state = ParseState :: new ( ) ; __err_state . reparse_for_error ( ) ; match __parse_peg_grammar ( __input , & mut __state , & mut __err_state , :: peg :: Parse :: start ( __input ) ) { Matched ( __pos , __value ) => { if __pos == __input . len ( ) { panic ! ( "Parser is nondeterministic: succeeded when reparsing for error position" ) ; } else { __err_state . mark_failure ( __pos , "EOF" ) ; } } _ => ( ) } Err ( __err_state . into_parse_error ( __input ) ) } fn __parse_peg_grammar < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > ) -> :: peg :: RuleResult < usize , Grammar > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "grammar" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"grammar\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_IDENT ( __input , __state , __err_state , __pos ) ; match __seq_res { Matched ( __pos , name ) => { { let __seq_res = __parse_grammar_args ( __input , __state , __err_state , __pos ) ; match __seq_res { Matched ( __pos , args ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "for" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"for\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let str_start = __pos ; match match __parse_rust_type ( __input , __state , __err_state , __pos ) { Matched ( pos , _ ) => Matched ( pos , ( ) ) , Failed => Failed , } { Matched ( __newpos , _ ) => { Matched ( __newpos , :: peg :: ParseSlice :: parse_slice ( __input , str_start , __newpos ) ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , input_type ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "{" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"{\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = __parse_item ( __input , __state , __err_state , __pos ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , __repeat_value ) } ; match __seq_res { Matched ( __pos , items ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "}" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"}\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { Grammar { name , args , input_type , items } } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } fn __parse_grammar_args < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > ) -> :: peg :: RuleResult < usize , Vec < ( Ident , TokenStream ) > > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "(" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"(\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . is_empty ( ) { __pos } else { let __sep_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "," ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\",\"" ) } ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } ; let __step_res = { let __seq_res = __parse_IDENT ( __input , __state , __err_state , __pos ) ; match __seq_res { Matched ( __pos , i ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ":" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\":\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let str_start = __pos ; match match __parse_rust_type ( __input , __state , __err_state , __pos ) { Matched ( pos , _ ) => Matched ( pos , ( ) ) , Failed => Failed , } { Matched ( __newpos , _ ) => { Matched ( __newpos , :: peg :: ParseSlice :: parse_slice ( __input , str_start , __newpos ) ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , t ) => { Matched ( __pos , { ( i , t ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , __repeat_value ) } ; match __seq_res { Matched ( __pos , args ) => { { let __seq_res = match match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "," ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\",\"" ) } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ")" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\")\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { args } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } fn __parse_peg_rule < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > ) -> :: peg :: RuleResult < usize , Rule > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = __parse_cacheflag ( __input , __state , __err_state , __pos ) ; match __seq_res { Matched ( __pos , cached ) => { { let __seq_res = __parse_rust_visibility ( __input , __state , __err_state , __pos ) ; match __seq_res { Matched ( __pos , visibility ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "rule" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"rule\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_IDENT ( __input , __state , __err_state , __pos ) ; match __seq_res { Matched ( __pos , name ) => { { let __seq_res = match { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "(" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"(\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ")" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\")\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { } ) } Failed => Failed , } } } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "->" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"->\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let str_start = __pos ; match match __parse_rust_type ( __input , __state , __err_state , __pos ) { Matched ( pos , _ ) => Matched ( pos , ( ) ) , Failed => Failed , } { Matched ( __newpos , _ ) => { Matched ( __newpos , :: peg :: ParseSlice :: parse_slice ( __input , str_start , __newpos ) ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , t ) => { Matched ( __pos , { t } ) } Failed => Failed , } } } Failed => Failed , } } { Matched ( __newpos , __value ) => { Matched ( __newpos , Some ( __value ) ) } , Failed => { Matched ( __pos , None ) } , } ; match __seq_res { Matched ( __pos , ret_type ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "=" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"=\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_expression ( __input , __state , __err_state , __pos ) ; match __seq_res { Matched ( __pos , expr ) => { { let __seq_res = match match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ";" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\";\"" ) } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { Rule { name , expr , ret_type , visibility , cached } } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } fn __parse_rust_visibility < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > ) -> :: peg :: RuleResult < usize , Option < TokenStream > > { # ! [ allow ( non_snake_case , unused ) ] match { let str_start = __pos ; match { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "pub" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"pub\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match match __parse_PAREN_GROUP ( __input , __state , __err_state , __pos ) { Matched ( pos , _ ) => Matched ( pos , ( ) ) , Failed => Failed , } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { } ) } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "crate" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"crate\"" ) } } } { Matched ( __newpos , _ ) => { Matched ( __newpos , :: peg :: ParseSlice :: parse_slice ( __input , str_start , __newpos ) ) } , Failed => Failed , } } { Matched ( __newpos , __value ) => { Matched ( __newpos , Some ( __value ) ) } , Failed => { Matched ( __pos , None ) } , } } fn __parse_cacheflag < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > ) -> :: peg :: RuleResult < usize , bool > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "#" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"#\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "[" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"[\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "cache" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"cache\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "]" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"]\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { true } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => Matched ( __pos , { false } ) } } } fn __parse_item < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > ) -> :: peg :: RuleResult < usize , Item > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { let __seq_res = __parse_rust_use ( __input , __state , __err_state , __pos ) ; match __seq_res { Matched ( __pos , u ) => { Matched ( __pos , { Item :: Use ( u ) } ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __seq_res = __parse_peg_rule ( __input , __state , __err_state , __pos ) ; match __seq_res { Matched ( __pos , r ) => { Matched ( __pos , { Item :: Rule ( r ) } ) } Failed => Failed , } } } } } fn __parse_rust_use < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > ) -> :: peg :: RuleResult < usize , TokenStream > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { let str_start = __pos ; match { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "use" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"use\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match __parse_rust_path ( __input , __state , __err_state , __pos ) { Matched ( pos , _ ) => Matched ( pos , ( ) ) , Failed => Failed , } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "::" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"::\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "*" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"*\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { } ) } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "::" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"::\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "{" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"{\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . is_empty ( ) { __pos } else { let __sep_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "," ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\",\"" ) } ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } ; let __step_res = { let __seq_res = match __parse_IDENT ( __input , __state , __err_state , __pos ) { Matched ( pos , _ ) => Matched ( pos , ( ) ) , Failed => Failed , } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "as" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"as\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match __parse_IDENT ( __input , __state , __err_state , __pos ) { Matched ( pos , _ ) => Matched ( pos , ( ) ) , Failed => Failed , } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { } ) } Failed => Failed , } } } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { } ) } Failed => Failed , } } } Failed => Failed , } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , ( ) ) } else { Failed } } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "}" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"}\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => match { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "as" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"as\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match __parse_IDENT ( __input , __state , __err_state , __pos ) { Matched ( pos , _ ) => Matched ( pos , ( ) ) , Failed => Failed , } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { } ) } Failed => Failed , } } } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } } } } } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ";" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\";\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , :: peg :: ParseSlice :: parse_slice ( __input , str_start , __newpos ) ) } , Failed => Failed , } } ; match __seq_res { Matched ( __pos , v ) => { Matched ( __pos , { v . to_owned ( ) } ) } Failed => Failed , } } } fn __parse_rust_path < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > ) -> :: peg :: RuleResult < usize , ( ) > { # ! [ allow ( non_snake_case , unused ) ] { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . is_empty ( ) { __pos } else { let __sep_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "::" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"::\"" ) } ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } ; let __step_res = match __parse_IDENT ( __input , __state , __err_state , __pos ) { Matched ( pos , _ ) => Matched ( pos , ( ) ) , Failed => Failed , } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , ( ) ) } else { Failed } } } fn __parse_rust_type < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > ) -> :: peg :: RuleResult < usize , ( ) > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = match __parse_BRACKET_GROUP ( __input , __state , __err_state , __pos ) { Matched ( pos , _ ) => Matched ( pos , ( ) ) , Failed => Failed , } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "&" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"&\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "mut" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"mut\"" ) } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match match __parse_LIFETIME ( __input , __state , __err_state , __pos ) { Matched ( pos , _ ) => Matched ( pos , ( ) ) , Failed => Failed , } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match __parse_rust_type ( __input , __state , __err_state , __pos ) { Matched ( pos , _ ) => Matched ( pos , ( ) ) , Failed => Failed , } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "dyn" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"dyn\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match __parse_rust_type ( __input , __state , __err_state , __pos ) { Matched ( pos , _ ) => Matched ( pos , ( ) ) , Failed => Failed , } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { } ) } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "impl" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"impl\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match __parse_rust_type ( __input , __state , __err_state , __pos ) { Matched ( pos , _ ) => Matched ( pos , ( ) ) , Failed => Failed , } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { } ) } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = match __parse_IDENT ( __input , __state , __err_state , __pos ) { Matched ( pos , _ ) => Matched ( pos , ( ) ) , Failed => Failed , } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "<" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"<\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . is_empty ( ) { __pos } else { let __sep_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "," ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\",\"" ) } ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } ; let __step_res = { let __choice_res = match __parse_LIFETIME ( __input , __state , __err_state , __pos ) { Matched ( pos , _ ) => Matched ( pos , ( ) ) , Failed => Failed , } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => match __parse_rust_type ( __input , __state , __err_state , __pos ) { Matched ( pos , _ ) => Matched ( pos , ( ) ) , Failed => Failed , } } } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , ( ) ) } else { Failed } } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ">" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\">\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = match __parse_IDENT ( __input , __state , __err_state , __pos ) { Matched ( pos , _ ) => Matched ( pos , ( ) ) , Failed => Failed , } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "::" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"::\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match __parse_rust_type ( __input , __state , __err_state , __pos ) { Matched ( pos , _ ) => Matched ( pos , ( ) ) , Failed => Failed , } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "(" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"(\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . is_empty ( ) { __pos } else { let __sep_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "," ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\",\"" ) } ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } ; let __step_res = match __parse_rust_type ( __input , __state , __err_state , __pos ) { Matched ( pos , _ ) => Matched ( pos , ( ) ) , Failed => Failed , } ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , ( ) ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ")" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\")\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => match __parse_IDENT ( __input , __state , __err_state , __pos ) { Matched ( pos , _ ) => Matched ( pos , ( ) ) , Failed => Failed , } } } } } } } } } } } } } } } } fn __parse_expression < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > ) -> :: peg :: RuleResult < usize , Expr > { # ! [ allow ( non_snake_case , unused ) ] __parse_choice ( __input , __state , __err_state , __pos ) } fn __parse_choice < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > ) -> :: peg :: RuleResult < usize , Expr > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __pos = if __repeat_value . is_empty ( ) { __pos } else { let __sep_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "/" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"/\"" ) } ; match __sep_res { Matched ( __newpos , _ ) => { __newpos } , Failed => break , } } ; let __step_res = __parse_sequence ( __input , __state , __err_state , __pos ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , __repeat_value ) } else { Failed } } ; match __seq_res { Matched ( __pos , s ) => { Matched ( __pos , { if s . len ( ) == 1 { s . into_iter ( ) . next ( ) . unwrap ( ) } else { ChoiceExpr ( s ) } } ) } Failed => Failed , } } } fn __parse_sequence < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > ) -> :: peg :: RuleResult < usize , Expr > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = __parse_labeled ( __input , __state , __err_state , __pos ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , __repeat_value ) } ; match __seq_res { Matched ( __pos , elements ) => { { let __seq_res = match __parse_code_block ( __input , __state , __err_state , __pos ) { Matched ( __newpos , __value ) => { Matched ( __newpos , Some ( __value ) ) } , Failed => { Matched ( __pos , None ) } , } ; match __seq_res { Matched ( __pos , code ) => { Matched ( __pos , { if let Some ( code ) = code { ActionExpr ( elements , Some ( code . 1 ) , code . 0 ) } else if elements . len ( ) != 1 { ActionExpr ( elements , None , false ) } else { elements . into_iter ( ) . next ( ) . unwrap ( ) . expr } } ) } Failed => Failed , } } } Failed => Failed , } } } fn __parse_code_block < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > ) -> :: peg :: RuleResult < usize , ( bool , TokenStream ) > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "{" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"{\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "?" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"?\"" ) } { Matched ( __newpos , __value ) => { Matched ( __newpos , Some ( __value ) ) } , Failed => { Matched ( __pos , None ) } , } ; match __seq_res { Matched ( __pos , is_cond ) => { { let __seq_res = __input . group_body ( __pos , ) ; match __seq_res { Matched ( __pos , code ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "}" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"}\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { ( is_cond . is_some ( ) , code ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } fn __parse_labeled < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > ) -> :: peg :: RuleResult < usize , TaggedExpr > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = match { let __seq_res = __parse_IDENT ( __input , __state , __err_state , __pos ) ; match __seq_res { Matched ( __pos , l ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ":" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\":\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { l } ) } Failed => Failed , } } } Failed => Failed , } } { Matched ( __newpos , __value ) => { Matched ( __newpos , Some ( __value ) ) } , Failed => { Matched ( __pos , None ) } , } ; match __seq_res { Matched ( __pos , label ) => { { let __seq_res = __parse_prefixed ( __input , __state , __err_state , __pos ) ; match __seq_res { Matched ( __pos , expression ) => { Matched ( __pos , { TaggedExpr { name : label , expr : expression } } ) } Failed => Failed , } } } Failed => Failed , } } } fn __parse_prefixed < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > ) -> :: peg :: RuleResult < usize , Expr > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "$" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"$\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_suffixed ( __input , __state , __err_state , __pos ) ; match __seq_res { Matched ( __pos , expression ) => { Matched ( __pos , { MatchStrExpr ( Box :: new ( expression ) ) } ) } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "&" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"&\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_suffixed ( __input , __state , __err_state , __pos ) ; match __seq_res { Matched ( __pos , expression ) => { Matched ( __pos , { PosAssertExpr ( Box :: new ( expression ) ) } ) } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "!" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"!\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_suffixed ( __input , __state , __err_state , __pos ) ; match __seq_res { Matched ( __pos , expression ) => { Matched ( __pos , { NegAssertExpr ( Box :: new ( expression ) ) } ) } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_suffixed ( __input , __state , __err_state , __pos ) } } } } } } } fn __parse_suffixed < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > ) -> :: peg :: RuleResult < usize , Expr > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { let __seq_res = __parse_primary ( __input , __state , __err_state , __pos ) ; match __seq_res { Matched ( __pos , e ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "?" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"?\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { OptionalExpr ( Box :: new ( e ) ) } ) } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = __parse_primary ( __input , __state , __err_state , __pos ) ; match __seq_res { Matched ( __pos , e ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "**" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"**\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_repeatcount ( __input , __state , __err_state , __pos ) ; match __seq_res { Matched ( __pos , count ) => { { let __seq_res = __parse_primary ( __input , __state , __err_state , __pos ) ; match __seq_res { Matched ( __pos , sep ) => { Matched ( __pos , { Repeat ( Box :: new ( e ) , count , Some ( Box :: new ( sep ) ) ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = __parse_primary ( __input , __state , __err_state , __pos ) ; match __seq_res { Matched ( __pos , e ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "++" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"++\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_primary ( __input , __state , __err_state , __pos ) ; match __seq_res { Matched ( __pos , sep ) => { Matched ( __pos , { Repeat ( Box :: new ( e ) , BoundedRepeat :: Plus , Some ( Box :: new ( sep ) ) ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = __parse_primary ( __input , __state , __err_state , __pos ) ; match __seq_res { Matched ( __pos , e ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "*" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"*\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_repeatcount ( __input , __state , __err_state , __pos ) ; match __seq_res { Matched ( __pos , count ) => { Matched ( __pos , { Repeat ( Box :: new ( e ) , count , None ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = __parse_primary ( __input , __state , __err_state , __pos ) ; match __seq_res { Matched ( __pos , e ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "+" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"+\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { Repeat ( Box :: new ( e ) , BoundedRepeat :: Plus , None ) } ) } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_primary ( __input , __state , __err_state , __pos ) } } } } } } } } } } } fn __parse_repeatcount < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > ) -> :: peg :: RuleResult < usize , BoundedRepeat > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "<" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"<\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_repeatnum ( __input , __state , __err_state , __pos ) ; match __seq_res { Matched ( __pos , n ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ">" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\">\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { BoundedRepeat :: Exact ( n ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "<" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"<\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match __parse_repeatnum ( __input , __state , __err_state , __pos ) { Matched ( __newpos , __value ) => { Matched ( __newpos , Some ( __value ) ) } , Failed => { Matched ( __pos , None ) } , } ; match __seq_res { Matched ( __pos , min ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "," ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\",\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match __parse_repeatnum ( __input , __state , __err_state , __pos ) { Matched ( __newpos , __value ) => { Matched ( __newpos , Some ( __value ) ) } , Failed => { Matched ( __pos , None ) } , } ; match __seq_res { Matched ( __pos , max ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ">" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\">\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { BoundedRepeat :: Both ( min , max ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => Matched ( __pos , { BoundedRepeat :: None } ) } } } } } fn __parse_repeatnum < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > ) -> :: peg :: RuleResult < usize , TokenStream > { # ! [ allow ( non_snake_case , unused ) ] { let str_start = __pos ; match { let __choice_res = match __parse_INTEGER ( __input , __state , __err_state , __pos ) { Matched ( pos , _ ) => Matched ( pos , ( ) ) , Failed => Failed , } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => match __parse_BRACE_GROUP ( __input , __state , __err_state , __pos ) { Matched ( pos , _ ) => Matched ( pos , ( ) ) , Failed => Failed , } } } { Matched ( __newpos , _ ) => { Matched ( __newpos , :: peg :: ParseSlice :: parse_slice ( __input , str_start , __newpos ) ) } , Failed => Failed , } } } fn __parse_primary < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > ) -> :: peg :: RuleResult < usize , Expr > { # ! [ allow ( non_snake_case , unused ) ] if let Some ( entry ) = __state . primary_cache . get ( & __pos ) { return entry . clone ( ) ; } let __rule_result = { let __choice_res = { let __seq_res = __parse_IDENT ( __input , __state , __err_state , __pos ) ; match __seq_res { Matched ( __pos , name ) => { { let __seq_res = match { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "(" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"(\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ")" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\")\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { } ) } Failed => Failed , } } } Failed => Failed , } } { Matched ( __newpos , _ ) => { Matched ( __newpos , ( ) ) } , Failed => { Matched ( __pos , ( ) ) } , } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { RuleExpr ( name ) } ) } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = __parse_LITERAL ( __input , __state , __err_state , __pos ) ; match __seq_res { Matched ( __pos , l ) => { Matched ( __pos , { LiteralExpr ( l ) } ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = __parse_BRACKET_GROUP ( __input , __state , __err_state , __pos ) ; match __seq_res { Matched ( __pos , p ) => { Matched ( __pos , { PatternExpr ( p ) } ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "@" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"@\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { MarkerExpr } ) } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "##" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"##\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_IDENT ( __input , __state , __err_state , __pos ) ; match __seq_res { Matched ( __pos , method ) => { { let __seq_res = __parse_PAREN_GROUP ( __input , __state , __err_state , __pos ) ; match __seq_res { Matched ( __pos , args ) => { Matched ( __pos , { MethodExpr ( method , args ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "#" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"#\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "position" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"position\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { PositionExpr } ) } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "#" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"#\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "quiet" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"quiet\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "<" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"<\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_expression ( __input , __state , __err_state , __pos ) ; match __seq_res { Matched ( __pos , e ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ">" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\">\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { QuietExpr ( Box :: new ( e ) ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "#" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"#\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "expected" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"expected\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "(" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"(\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_LITERAL ( __input , __state , __err_state , __pos ) ; match __seq_res { Matched ( __pos , s ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ")" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\")\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { FailExpr ( s ) } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "#" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"#\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "infix" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"infix\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "<" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"<\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_expression ( __input , __state , __err_state , __pos ) ; match __seq_res { Matched ( __pos , atom ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ">" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\">\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "{" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"{\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = __parse_infix_level ( __input , __state , __err_state , __pos ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , __repeat_value ) } else { Failed } } ; match __seq_res { Matched ( __pos , levels ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "}" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"}\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { InfixExpr { atom : Box :: new ( atom ) , levels : levels } } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "(" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"(\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __parse_expression ( __input , __state , __err_state , __pos ) ; match __seq_res { Matched ( __pos , expression ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , ")" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\")\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { expression } ) } Failed => Failed , } } } Failed => Failed , } } } Failed => Failed , } } } } } } } } } } } } } } } } } } } } ; __state . primary_cache . insert ( __pos , __rule_result . clone ( ) ) ; __rule_result } fn __parse_infix_level < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > ) -> :: peg :: RuleResult < usize , InfixLevel > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { let __choice_res = { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "#" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"#\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "L" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"L\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { InfixAssoc :: Left } ) } Failed => Failed , } } } Failed => Failed , } } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "#" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"#\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "R" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"R\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { InfixAssoc :: Right } ) } Failed => Failed , } } } Failed => Failed , } } } } ; match __seq_res { Matched ( __pos , assoc ) => { { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = __parse_infix_op ( __input , __state , __err_state , __pos ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } if __repeat_value . len ( ) >= 1 { Matched ( __repeat_pos , __repeat_value ) } else { Failed } } ; match __seq_res { Matched ( __pos , operators ) => { Matched ( __pos , { InfixLevel { assoc : assoc , operators : operators } } ) } Failed => Failed , } } } Failed => Failed , } } } fn __parse_infix_op < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > ) -> :: peg :: RuleResult < usize , InfixOperator > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { let mut __repeat_pos = __pos ; let mut __repeat_value = vec ! ( ) ; loop { let __pos = __repeat_pos ; let __step_res = __parse_labeled ( __input , __state , __err_state , __pos ) ; match __step_res { Matched ( __newpos , __value ) => { __repeat_pos = __newpos ; __repeat_value . push ( __value ) ; } , Failed => { break ; } } } Matched ( __repeat_pos , __repeat_value ) } ; match __seq_res { Matched ( __pos , elements ) => { { let __seq_res = __parse_BRACE_GROUP ( __input , __state , __err_state , __pos ) ; match __seq_res { Matched ( __pos , action ) => { Matched ( __pos , { InfixOperator { elements , action } } ) } Failed => Failed , } } } Failed => Failed , } } } fn __parse_KEYWORD < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > ) -> :: peg :: RuleResult < usize , ( ) > { # ! [ allow ( non_snake_case , unused ) ] { let __choice_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "pub" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"pub\"" ) } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "crate" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"crate\"" ) } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "rule" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"rule\"" ) } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "use" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"use\"" ) } ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "type" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"type\"" ) } } } } } } } } } } fn __parse_IDENT < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > ) -> :: peg :: RuleResult < usize , Ident > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = { __err_state . suppress_fail += 1 ; let __assert_res = match __parse_KEYWORD ( __input , __state , __err_state , __pos ) { Matched ( pos , _ ) => Matched ( pos , ( ) ) , Failed => Failed , } ; __err_state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = __input . ident ( __pos , ) ; match __seq_res { Matched ( __pos , i ) => { Matched ( __pos , { i } ) } Failed => Failed , } } } Failed => Failed , } } } fn __parse_LITERAL < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > ) -> :: peg :: RuleResult < usize , Literal > { # ! [ allow ( non_snake_case , unused ) ] __input . literal ( __pos , ) } fn __parse_PAREN_GROUP < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > ) -> :: peg :: RuleResult < usize , TokenStream > { # ! [ allow ( non_snake_case , unused ) ] __input . group ( __pos , Delimiter :: Parenthesis ) } fn __parse_BRACE_GROUP < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > ) -> :: peg :: RuleResult < usize , TokenStream > { # ! [ allow ( non_snake_case , unused ) ] __input . group ( __pos , Delimiter :: Brace ) } fn __parse_BRACKET_GROUP < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > ) -> :: peg :: RuleResult < usize , TokenStream > { # ! [ allow ( non_snake_case , unused ) ] __input . group ( __pos , Delimiter :: Bracket ) } fn __parse_LIFETIME < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > ) -> :: peg :: RuleResult < usize , ( ) > { # ! [ allow ( non_snake_case , unused ) ] { let __seq_res = match :: peg :: ParseLiteral :: parse_string_literal ( __input , __pos , "'" ) { Matched ( __pos , __val ) => Matched ( __pos , __val ) , Failed => __err_state . mark_failure ( __pos , "\"'\"" ) } ; match __seq_res { Matched ( __pos , _ ) => { { let __seq_res = match __parse_IDENT ( __input , __state , __err_state , __pos ) { Matched ( pos , _ ) => Matched ( pos , ( ) ) , Failed => Failed , } ; match __seq_res { Matched ( __pos , _ ) => { Matched ( __pos , { } ) } Failed => Failed , } } } Failed => Failed , } } } fn __parse_INTEGER < 'input > ( __input : & 'input Input , __state : & mut ParseState < 'input > , __err_state : & mut :: peg :: error :: ErrorState < Position < 'input >> , __pos : Position < 'input > ) -> :: peg :: RuleResult < usize , ( ) > { # ! [ allow ( non_snake_case , unused ) ] match __parse_LITERAL ( __input , __state , __err_state , __pos ) { Matched ( pos , _ ) => Matched ( pos , ( ) ) , Failed => Failed , } } }